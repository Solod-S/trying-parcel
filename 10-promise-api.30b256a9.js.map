{"version":3,"sources":["js/10-promise-api.js"],"names":["promise","Promise","resolve","reject","canFulfill","Math","random","setTimeout","onFulfilled","result","console","log","onRejected","error","then","success","notsuccess","x","y","catch","finally"],"mappings":";AAQA,IAAMA,EAAU,IAAIC,QAAQ,SAACC,EAASC,GAEpC,IAAMC,EAAaC,KAAKC,SAAW,GAGnCC,WAAW,WACLH,GACFF,EACE,yEAIJC,EAAO,yDAEN,OAUL,SAASK,EAAYC,GAEnBC,QAAQC,IAASF,KAAAA,OAAAA,IAGnB,SAASG,EAAWC,GAElBH,QAAQC,IAASE,KAAAA,OAAAA,IAfnBb,EAAQc,KACN,SAACC,GAAD,OAAaL,QAAQC,IAAII,IACzB,SAACC,GAAD,OAAgBN,QAAQC,IAAIK,KAI9BhB,EAAQc,KAAKN,EAAaI,GAkB1BZ,EACGc,KAAKN,GACLM,KAAK,SAACG,GAGL,OAFAP,QAAQC,IAAIM,GAEL,KAERH,KAAK,SAACI,GACLR,QAAQC,IAAIO,KAEbC,MAAM,SAACN,GAAD,OAAWH,QAAQC,IAAIE,KAG7BO,QAAQ,WAAA,OAAMV,QAAQC,IAAI","file":"10-promise-api.30b256a9.js","sourceRoot":"../src","sourcesContent":["/*\n * Создание промиса\n *  - Класс Promise\n *  - resolve\n *  - reject\n *  - Promise.prototype.then(onResolve, onReject)\n */\n\nconst promise = new Promise((resolve, reject) => {\n  // первый аргумент - успешное выполнение, второй аргумент - не успешное выполнение\n  const canFulfill = Math.random() > 0.5;\n  // гениратор true-false\n\n  setTimeout(() => {\n    if (canFulfill) {\n      resolve(\n        \"СУПЕР! Промис выполнился успешно, с результатом (исполнен, fulfilled)\"\n      );\n    }\n    // если результат true\n    reject(\"УПС Промис выполнился с ошибкой (отклонён, rejected)\");\n    // если результат false\n  }, 1000);\n});\npromise.then(\n  (success) => console.log(success),\n  (notsuccess) => console.log(notsuccess)\n);\n// первый аргумент - успешное выполнение resolve, второй аргумент - не успешное выполнение reject\n\npromise.then(onFulfilled, onRejected);\n// тоже самое но с колбекфункциями\nfunction onFulfilled(result) {\n  // console.log(\"onFulfilled -> onFulfilled\");\n  console.log(`✅ ${result}`);\n}\n\nfunction onRejected(error) {\n  // console.log(\"onRejected -> onRejected\");\n  console.log(`❌ ${error}`);\n}\n\n// /*\n//  * Цепочки промисов (chaining)\n//  * Promise.prototype.catch(error)\n//  * Promise.prototype.finally()\n//  */\n\npromise\n  .then(onFulfilled)\n  .then((x) => {\n    console.log(x);\n    // возврат(return) call-back функции внутри .then становиться значением следующего .then в цепочки\n    return 10;\n  })\n  .then((y) => {\n    console.log(y);\n  })\n  .catch((error) => console.log(error))\n  // отлавливает ошибку в любом месте цепочки (чтобы не писать .then(успешное, неуспешное))\n  // если ловит ошибку в цепочки то цепочка останавливаеться и выполняеться catch\n  .finally(() => console.log(\"Я буду выполнен в любом случае\"));\n// then есои хорошо, catch если плохо, а finally в любом случае\n\n//.then(успешное, неуспешное) ТАК НЕ ДЕЛАЕМ, всегда передаем успешное выполнение + catch который ловит ошибки и не дает выолнить успешное выполнение в промисе\n"]}