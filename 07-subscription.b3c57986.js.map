{"version":3,"sources":["../node_modules/bootstrap.native/dist/bootstrap-native.esm.js","js/07-subscription.js"],"names":["EventRegistry","globalListener","e","that","type","forEach","elementsMap","element","listenersMap","listenerMap","listener","options","apply","once","removeListener","addListener","eventType","Map","oneEventMap","has","set","oneElementMap","get","size","addEventListener","savedOptions","eventOptions","undefined","delete","removeEventListener","Listener","on","off","registry","mouseclickEvent","transitionEndEvent","transitionDelay","transitionProperty","getElementStyle","property","computedStyle","getComputedStyle","includes","getPropertyValue","getElementTransitionDelay","propertyValue","delayValue","delayScale","duration","parseFloat","Number","isNaN","transitionDuration","getElementTransitionDuration","durationValue","durationScale","dispatchEvent","event","emulateTransitionEnd","handler","called","endEvent","Event","delay","transitionEndWrapper","target","setTimeout","isNode","some","x","nodeType","isWindow","object","constructor","name","isDocument","getDocument","node","ownerDocument","document","window","querySelector","selector","parent","closest","getRootNode","host","ObjectAssign","obj","source","Object","assign","hasClass","classNAME","classList","contains","removeClass","remove","isHTMLElement","componentData","Data","component","instance","getAllFor","allForC","instanceMap","getInstance","isObject","OriginalEvent","EventType","config","OriginalCustomEvent","CustomEvent","cancelable","bubbles","fadeClass","showClass","dataBsDismiss","alertString","alertComponent","getAttribute","attribute","normalizeValue","value","ObjectKeys","keys","toLowerCase","normalizeOptions","defaultOps","inputOps","ns","data","dataset","normalOps","dataOps","k","key","replace","match","version","Version","BaseComponent","Error","self","prevInstance","dispose","defaults","length","prop","alertSelector","alertDismissSelector","getAlertInstance","alertInitCallback","Alert","closeAlertEvent","closedAlertEvent","alertTransitionEnd","toggleAlertHandler","add","action","dismiss","close","defaultPrevented","init","ariaPressed","setAttribute","addClass","activeClass","dataBsToggle","buttonString","buttonComponent","buttonSelector","getButtonInstance","buttonInitCallback","Button","toggleButtonHandler","toggle","isActive","preventDefault","mouseenterEvent","mouseleaveEvent","keydownEvent","keyArrowLeft","keyArrowRight","pointerdownEvent","pointermoveEvent","pointerupEvent","getBoundingClientRect","includeScale","width","height","top","right","bottom","left","scaleX","scaleY","offsetWidth","offsetHeight","Math","round","y","getDocumentElement","documentElement","isElementInScrollRange","clientHeight","isRTL","dir","querySelectorAll","getElementsByClassName","TimeCache","Timer","callback","keyTimers","clear","clearTimeout","reflow","passiveHandler","passive","dataBsTarget","carouselString","carouselComponent","dataBsParent","dataBsContainer","getTargetElement","targetAttr","doc","map","att","attValue","filter","carouselSelector","carouselItem","dataBsSlideTo","dataBsSlide","pausedClass","carouselDefaults","pause","keyboard","touch","interval","getCarouselInstance","carouselInitCallback","Carousel","startX","currentX","endX","carouselSlideEvent","carouselSlidEvent","carouselTransitionEndHandler","index","direction","slides","isAnimating","activeItem","getActiveIndex","orientation","directionClass","hidden","isPaused","cycle","carouselPauseHandler","carouselResumeHandler","carouselIndicatorHandler","newIndex","to","carouselControlsHandler","next","prev","carouselKeyHandler","code","test","tagName","RTL","arrowKeyNext","carouselPointerDownHandler","controls","indicators","el","isTouch","pageX","toggleCarouselTouchHandlers","carouselPointerMoveHandler","carouselPointerUpHandler","c","find","i","getSelection","toString","abs","activateCarouselIndicator","pageIndex","toggleCarouselHandlers","arrow","indicator","indexOf","id","idx","eventProperties","relatedTarget","from","itemClasses","slide","ariaExpanded","ObjectEntries","entries","setElementStyle","styles","style","setProperty","propObject","collapsingClass","collapseString","collapseComponent","collapseSelector","collapseToggleSelector","collapseDefaults","getCollapseInstance","collapseInitCallback","Collapse","showCollapseEvent","shownCollapseEvent","hideCollapseEvent","hiddenCollapseEvent","expandCollapse","triggers","scrollHeight","btn","collapseContent","toggleCollapseHandler","collapseClickHandler","trigger","hide","show","activeCollapse","activeCollapseInstance","focusEvent","keyupEvent","scrollEvent","resizeEvent","keyArrowUp","keyArrowDown","keyEscape","hasAttribute","focus","getWindow","defaultView","dropdownMenuClasses","dropdownComponent","dropdownMenuClass","isEmptyAnchor","parentAnchor","href","slice","dropdownString","dropupString","dropstartString","dropendString","dropdownSelector","getDropdownInstance","dropdownInitCallback","Dropdown","dropdownMenuEndClass","verticalClass","horizontalClass","menuFocusTags","dropdownDefaults","offset","display","showDropdownEvent","shownDropdownEvent","hideDropdownEvent","hiddenDropdownEvent","styleDropdown","menu","parentElement","menuEnd","p","posAjust","positionClass","dropdownMargin","dropdown","dropup","dropstart","dropend","dropdownPosition","menuStart","menuWidth","menuHeight","clientWidth","targetLeft","targetTop","targetWidth","leftFullExceed","rightFullExceed","bottomExceed","bottomFullExceed","topExceed","leftExceed","rightExceed","margin","join","getMenuItems","children","firstElementChild","toggleDropdownDismiss","open","dropdownDismissHandler","dropdownPreventScroll","dropdownKeyHandler","ev","dropdownLayoutHandler","toggleDropdownHandler","dropdownClickHandler","getCurrentOpenDropdown","currentParent","hasData","isForm","activeElement","menuItems","currentElement","currentInstance","ariaHidden","ariaModal","removeAttribute","getDocumentBody","body","modalString","modalComponent","isShadowRoot","getParentNode","nodeName","assignedSlot","parentNode","isTableElement","getElementContainer","getOffset","majorBlockTags","offsetParent","win","containers","shadowRoot","push","every","r","fixedTopClass","fixedBottomClass","stickyTopClass","positionStickyClass","getFixedItems","resetScrollbar","bd","paddingRight","overflow","fixedItems","fixed","marginRight","measureScrollbar","innerWidth","setScrollbar","bodyPad","parseInt","sbWidth","itemPadValue","itemMValue","createElement","param","attr","newElement","offcanvasString","backdropString","modalBackdropClass","offcanvasBackdropClass","modalActiveSelector","offcanvasActiveSelector","overlay","getCurrentOpen","toggleOverlayType","isModal","targetClass","appendOverlay","container","hasFade","append","showOverlay","hideOverlay","removeOverlay","isVisible","modalSelector","modalToggleSelector","modalDismissSelector","modalStaticClass","modalDefaults","backdrop","getModalInstance","modalInitCallback","Modal","showModalEvent","shownModalEvent","hideModalEvent","hiddenModalEvent","setModalScrollbar","scrollbarWidth","modalOverflow","padStyle","toggleModalDismiss","modalDismissHandler","update","modalKeyHandler","toggleModalHandler","modalClickHandler","afterModalHide","focusElement","afterModalShow","beforeModalShow","beforeModalHide","isStatic","modalDialog","selectedText","targetInsideDialog","staticTransitionEnd","bind","overlayDelay","currentOpen","offcanvasComponent","offcanvasSelector","offcanvasToggleSelector","offcanvasDismissSelector","offcanvasTogglingClass","offcanvasDefaults","scroll","getOffcanvasInstance","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","toggleOffcanvasEvents","offcanvasTriggerHandler","toggleOffCanvasDismiss","offcanvasKeyDismissHandler","offcanvasDismissHandler","beforeOffcanvasShow","visibility","showOffcanvasComplete","beforeOffcanvasHide","blur","hideOffcanvasComplete","offCanvasDismiss","selection","visibleTrigger","popoverString","popoverComponent","tooltipString","getTipTemplate","tipType","isTooltip","bodyClass","header","isMedia","s","getNodeScroll","isWin","scrollX","scrollLeft","scrollY","scrollTop","isScaledElement","getRectRelativeToOffsetParent","isParentAnElement","rect","offsets","offsetRect","clientLeft","clientTop","tipClassPositions","styleTip","tooltip","tipPositions","topPosition","leftPosition","rightPosition","arrowTop","arrowLeft","arrowRight","isPopover","tipWidth","tipHeight","htmlcw","htmlch","placement","parentLeft","parentRight","parentTop","parentCWidth","parentOWidth","parentPosition","fixedParent","staticParent","isSticky","leftBoundry","rightBoundry","elemWidth","elemHeight","elemRectLeft","elemRectRight","elemRectTop","arrowWidth","arrowHeight","arrowAdjust","horizontal","vertical","className","eX","eY","pageY","clientX","clientY","tooltipDefaults","template","title","customClass","sanitizeFn","animation","ariaDescribedBy","mousedownEvent","mousemoveEvent","focusinEvent","focusoutEvent","mousehoverEvent","touchstartEvent","elementUID","elementMapUID","elementIDMap","getUID","result","elID","elMap","elkey","isFunction","fn","navigator","uaDATA","userAgentData","userAgentString","userAgent","appleBrands","isApple","brands","brand","dataOriginalTitle","tooltipComponent","isNodeList","isString","str","isArray","arr","Array","setHtml","content","dirty","trim","tempDocument","DOMParser","parseFromString","childNodes","createTip","dismissible","btnClose","tipString","titleParts","contentParts","tooltipTemplate","placementClass","htmlMarkup","firstChild","cloneNode","tooltipHeader","tooltipBody","tempTitle","tempContent","tempBtn","isVisibleTip","tip","tooltipSelector","titleAttr","getTooltipInstance","tooltipInitCallback","Tooltip","removeTooltip","disposeTooltipComplete","toggleTooltipHandlers","toggleTooltipTitle","toggleTooltipAction","handleTouch","tooltipShownAction","shownTooltipEvent","tooltipHiddenAction","hiddenTooltipEvent","enabled","triggerOptions","split","elemIsMedia","tr","toggleTooltipOpenHandlers","parentModal","parentOffcanvas","scrollTarget","titleAtt","tipComponent","elem","idealContainer","outTimer","showTooltipEvent","hideTooltipEvent","disable","enable","popoverSelector","popoverDefaults","Popover","getPopoverInstance","popoverInitCallback","getElementsByTagName","scrollspyString","scrollspyComponent","scrollspySelector","scrollspyDefaults","getScrollSpyInstance","scrollspyInitCallback","ScrollSpy","activateScrollSpy","updateSpyTargets","targetItem","itemsLength","links","scrollHEIGHT","getScrollHeight","items","maxScroll","getOffsetHeight","link","charAt","offsetTop","innerHeight","item","activate","parents","parentItem","menuItem","parentLink","previousElementSibling","toggleSpyHandlers","refresh","newActiveItem","ariaSelected","tabString","tabComponent","tabSelector","getTabInstance","tabInitCallback","Tab","showTabEvent","shownTabEvent","hideTabEvent","hiddenTabEvent","tabPrivate","triggerTabEnd","tabContent","nav","triggerTabShow","nextContent","tab","currentHeight","nextHeight","triggerTabHide","getActiveTab","activeTabs","getParentDropdown","toggleTabHandler","tabClickHandler","firstTab","firstTabContent","activeDropdown","toggleTab","toastString","toastComponent","toastSelector","toastDismissSelector","toastToggleSelector","showingClass","hideClass","toastDefaults","autohide","getToastInstance","toastInitCallback","Toast","showToastEvent","shownToastEvent","hideToastEvent","hiddenToastEvent","showToastComplete","hideToastComplete","hideToast","showToast","toggleToastHandlers","interactiveToastHandler","toastClickHandler","completeDisposeToast","isShown","matches","componentsList","initComponentDataAPI","collection","removeComponentDataAPI","context","compData","initCallback","elemCollection","comp","removeDataAPI","lookUp","BSN","EventListener","refs","modal","subscribeBtn","PROMPT_DELAY","MAX_PROMPT_ATTEMPTS","promptCounter","hasSubscribed","openModal","console","log","onSubscribeBtnClick"],"mappings":"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","file":"07-subscription.b3c57986.js","sourceRoot":"../src","sourcesContent":["/*!\n  * Native JavaScript for Bootstrap v4.2.0 (https://thednp.github.io/bootstrap.native/)\n  * Copyright 2015-2022 © dnp_theme\n  * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)\n  */\n/** @type {Record<string, any>} */\nconst EventRegistry = {};\n\n/**\n * The global event listener.\n *\n * @type {EventListener}\n * @this {EventTarget}\n */\nfunction globalListener(e) {\n  const that = this;\n  const { type } = e;\n\n  [...EventRegistry[type]].forEach((elementsMap) => {\n    const [element, listenersMap] = elementsMap;\n    /* istanbul ignore else */\n    if (element === that) {\n      [...listenersMap].forEach((listenerMap) => {\n        const [listener, options] = listenerMap;\n        listener.apply(element, [e]);\n\n        if (options && options.once) {\n          removeListener(element, type, listener, options);\n        }\n      });\n    }\n  });\n}\n\n/**\n * Register a new listener with its options and attach the `globalListener`\n * to the target if this is the first listener.\n *\n * @type {Listener.ListenerAction<EventTarget>}\n */\nconst addListener = (element, eventType, listener, options) => {\n  // get element listeners first\n  if (!EventRegistry[eventType]) {\n    EventRegistry[eventType] = new Map();\n  }\n  const oneEventMap = EventRegistry[eventType];\n\n  if (!oneEventMap.has(element)) {\n    oneEventMap.set(element, new Map());\n  }\n  const oneElementMap = oneEventMap.get(element);\n\n  // get listeners size\n  const { size } = oneElementMap;\n\n  // register listener with its options\n  oneElementMap.set(listener, options);\n\n  // add listener last\n  if (!size) {\n    element.addEventListener(eventType, globalListener, options);\n  }\n};\n\n/**\n * Remove a listener from registry and detach the `globalListener`\n * if no listeners are found in the registry.\n *\n * @type {Listener.ListenerAction<EventTarget>}\n */\nconst removeListener = (element, eventType, listener, options) => {\n  // get listener first\n  const oneEventMap = EventRegistry[eventType];\n  const oneElementMap = oneEventMap && oneEventMap.get(element);\n  const savedOptions = oneElementMap && oneElementMap.get(listener);\n\n  // also recover initial options\n  const { options: eventOptions } = savedOptions !== undefined\n    ? savedOptions\n    : { options };\n\n  // unsubscribe second, remove from registry\n  if (oneElementMap && oneElementMap.has(listener)) oneElementMap.delete(listener);\n  if (oneEventMap && (!oneElementMap || !oneElementMap.size)) oneEventMap.delete(element);\n  if (!oneEventMap || !oneEventMap.size) delete EventRegistry[eventType];\n\n  // remove listener last\n  /* istanbul ignore else */\n  if (!oneElementMap || !oneElementMap.size) {\n    element.removeEventListener(eventType, globalListener, eventOptions);\n  }\n};\n\n/**\n * Advanced event listener based on subscribe / publish pattern.\n * @see https://www.patterns.dev/posts/classic-design-patterns/#observerpatternjavascript\n * @see https://gist.github.com/shystruk/d16c0ee7ac7d194da9644e5d740c8338#file-subpub-js\n * @see https://hackernoon.com/do-you-still-register-window-event-listeners-in-each-component-react-in-example-31a4b1f6f1c8\n */\nconst Listener = {\n  on: addListener,\n  off: removeListener,\n  globalListener,\n  registry: EventRegistry,\n};\n\n/**\n * A global namespace for `click` event.\n * @type {string}\n */\nconst mouseclickEvent = 'click';\n\n/**\n * A global namespace for 'transitionend' string.\n * @type {string}\n */\nconst transitionEndEvent = 'transitionend';\n\n/**\n * A global namespace for 'transitionDelay' string.\n * @type {string}\n */\nconst transitionDelay = 'transitionDelay';\n\n/**\n * A global namespace for `transitionProperty` string for modern browsers.\n *\n * @type {string}\n */\nconst transitionProperty = 'transitionProperty';\n\n/**\n * Shortcut for `window.getComputedStyle(element).propertyName`\n * static method.\n *\n * * If `element` parameter is not an `HTMLElement`, `getComputedStyle`\n * throws a `ReferenceError`.\n *\n * @param {HTMLElement} element target\n * @param {string} property the css property\n * @return {string} the css property value\n */\nfunction getElementStyle(element, property) {\n  const computedStyle = getComputedStyle(element);\n\n  // must use camelcase strings,\n  // or non-camelcase strings with `getPropertyValue`\n  return property.includes('--')\n    ? computedStyle.getPropertyValue(property)\n    : computedStyle[property];\n}\n\n/**\n * Utility to get the computed `transitionDelay`\n * from Element in miliseconds.\n *\n * @param {HTMLElement} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDelay(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const delayValue = getElementStyle(element, transitionDelay);\n  const delayScale = delayValue.includes('ms') ? /* istanbul ignore next */1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(delayValue) * delayScale : 0;\n\n  return !Number.isNaN(duration) ? duration : /* istanbul ignore next */0;\n}\n\n/**\n * A global namespace for 'transitionDuration' string.\n * @type {string}\n */\nconst transitionDuration = 'transitionDuration';\n\n/**\n * Utility to get the computed `transitionDuration`\n * from Element in miliseconds.\n *\n * @param {HTMLElement} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDuration(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const durationValue = getElementStyle(element, transitionDuration);\n  const durationScale = durationValue.includes('ms') ? /* istanbul ignore next */1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(durationValue) * durationScale : 0;\n\n  return !Number.isNaN(duration) ? duration : /* istanbul ignore next */0;\n}\n\n/**\n * Shortcut for the `Element.dispatchEvent(Event)` method.\n *\n * @param {HTMLElement} element is the target\n * @param {Event} event is the `Event` object\n */\nconst dispatchEvent = (element, event) => element.dispatchEvent(event);\n\n/**\n * Utility to make sure callbacks are consistently\n * called when transition ends.\n *\n * @param {HTMLElement} element target\n * @param {EventListener} handler `transitionend` callback\n */\nfunction emulateTransitionEnd(element, handler) {\n  let called = 0;\n  const endEvent = new Event(transitionEndEvent);\n  const duration = getElementTransitionDuration(element);\n  const delay = getElementTransitionDelay(element);\n\n  if (duration) {\n    /**\n     * Wrap the handler in on -> off callback\n     * @type {EventListener} e Event object\n     */\n    const transitionEndWrapper = (e) => {\n      /* istanbul ignore else */\n      if (e.target === element) {\n        handler.apply(element, [e]);\n        element.removeEventListener(transitionEndEvent, transitionEndWrapper);\n        called = 1;\n      }\n    };\n    element.addEventListener(transitionEndEvent, transitionEndWrapper);\n    setTimeout(() => {\n      /* istanbul ignore next */\n      if (!called) dispatchEvent(element, endEvent);\n    }, duration + delay + 17);\n  } else {\n    handler.apply(element, [endEvent]);\n  }\n}\n\n/**\n * Checks if an object is a `Node`.\n *\n * @param {any} node the target object\n * @returns {boolean} the query result\n */\nconst isNode = (element) => (element && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n  .some((x) => +element.nodeType === x)) || false;\n\n/**\n * Check if a target object is `Window`.\n * => equivalent to `object instanceof Window`\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isWindow = (object) => (object && object.constructor.name === 'Window') || false;\n\n/**\n * Checks if an object is a `Document`.\n * @see https://dom.spec.whatwg.org/#node\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isDocument = (object) => (object && object.nodeType === 9) || false;\n\n/**\n * Returns the `document` or the `#document` element.\n * @see https://github.com/floating-ui/floating-ui\n * @param {(Node | Window)=} node\n * @returns {Document}\n */\nfunction getDocument(node) {\n  // node instanceof Document\n  if (isDocument(node)) return node;\n  // node instanceof Node\n  if (isNode(node)) return node.ownerDocument;\n  // node instanceof Window\n  if (isWindow(node)) return node.document;\n  // node is undefined | NULL\n  return window.document;\n}\n\n/**\n * Utility to check if target is typeof `HTMLElement`, `Element`, `Node`\n * or find one that matches a selector.\n *\n * @param {Node | string} selector the input selector or target element\n * @param {ParentNode=} parent optional node to look into\n * @return {HTMLElement?} the `HTMLElement` or `querySelector` result\n */\nfunction querySelector(selector, parent) {\n  if (isNode(selector)) {\n    return selector;\n  }\n  const lookUp = isNode(parent) ? parent : getDocument();\n\n  return lookUp.querySelector(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.closest` method which also works\n * with children of `ShadowRoot`. The order of the parameters\n * is intentional since they're both required.\n *\n * @see https://stackoverflow.com/q/54520554/803358\n *\n * @param {HTMLElement} element Element to look into\n * @param {string} selector the selector name\n * @return {HTMLElement?} the query result\n */\nfunction closest(element, selector) {\n  return element ? (element.closest(selector)\n    // break out of `ShadowRoot`\n    || closest(element.getRootNode().host, selector)) : null;\n}\n\n/**\n * Shortcut for `Object.assign()` static method.\n * @param  {Record<string, any>} obj a target object\n * @param  {Record<string, any>} source a source object\n */\nconst ObjectAssign = (obj, source) => Object.assign(obj, source);\n\n/**\n * Check class in `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to check\n * @returns {boolean}\n */\nfunction hasClass(element, classNAME) {\n  return element.classList.contains(classNAME);\n}\n\n/**\n * Remove class from `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to remove\n * @returns {void}\n */\nfunction removeClass(element, classNAME) {\n  element.classList.remove(classNAME);\n}\n\n/**\n * Checks if an element is an `HTMLElement`.\n * @see https://dom.spec.whatwg.org/#node\n *\n * @param {any} element the target object\n * @returns {boolean} the query result\n */\nconst isHTMLElement = (element) => (element && element.nodeType === 1) || false;\n\n/** @type {Map<string, Map<HTMLElement, Record<string, any>>>} */\nconst componentData = new Map();\n/**\n * An interface for web components background data.\n * @see https://github.com/thednp/bootstrap.native/blob/master/src/components/base-component.js\n */\nconst Data = {\n  /**\n   * Sets web components data.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   * @param {Record<string, any>} instance the component instance\n   */\n  set: (element, component, instance) => {\n    if (!isHTMLElement(element)) return;\n\n    /* istanbul ignore else */\n    if (!componentData.has(component)) {\n      componentData.set(component, new Map());\n    }\n\n    const instanceMap = componentData.get(component);\n    // not undefined, but defined right above\n    instanceMap.set(element, instance);\n  },\n\n  /**\n   * Returns all instances for specified component.\n   * @param {string} component the component's name or a unique key\n   * @returns {Map<HTMLElement, Record<string, any>>?} all the component instances\n   */\n  getAllFor: (component) => {\n    const instanceMap = componentData.get(component);\n\n    return instanceMap || null;\n  },\n\n  /**\n   * Returns the instance associated with the target.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   * @returns {Record<string, any>?} the instance\n   */\n  get: (element, component) => {\n    if (!isHTMLElement(element) || !component) return null;\n    const allForC = Data.getAllFor(component);\n    const instance = element && allForC && allForC.get(element);\n\n    return instance || null;\n  },\n\n  /**\n   * Removes web components data.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   */\n  remove: (element, component) => {\n    const instanceMap = componentData.get(component);\n    if (!instanceMap || !isHTMLElement(element)) return;\n\n    instanceMap.delete(element);\n\n    /* istanbul ignore else */\n    if (instanceMap.size === 0) {\n      componentData.delete(component);\n    }\n  },\n};\n\n/**\n * An alias for `Data.get()`.\n * @type {SHORTY.getInstance<any>}\n */\nconst getInstance = (target, component) => Data.get(target, component);\n\n/**\n * Checks if an object is an `Object`.\n *\n * @param {any} obj the target object\n * @returns {boolean} the query result\n */\nconst isObject = (obj) => (typeof obj === 'object') || false;\n\n/**\n * Returns a namespaced `CustomEvent` specific to each component.\n * @param {string} EventType Event.type\n * @param {Record<string, any>=} config Event.options | Event.properties\n * @returns {SHORTY.OriginalEvent} a new namespaced event\n */\nfunction OriginalEvent(EventType, config) {\n  const OriginalCustomEvent = new CustomEvent(EventType, {\n    cancelable: true, bubbles: true,\n  });\n\n  /* istanbul ignore else */\n  if (isObject(config)) {\n    ObjectAssign(OriginalCustomEvent, config);\n  }\n  return OriginalCustomEvent;\n}\n\n/**\n * Global namespace for most components `fade` class.\n */\nconst fadeClass = 'fade';\n\n/**\n * Global namespace for most components `show` class.\n */\nconst showClass = 'show';\n\n/**\n * Global namespace for most components `dismiss` option.\n */\nconst dataBsDismiss = 'data-bs-dismiss';\n\n/** @type {string} */\nconst alertString = 'alert';\n\n/** @type {string} */\nconst alertComponent = 'Alert';\n\n/**\n * Shortcut for `HTMLElement.getAttribute()` method.\n * @param {HTMLElement} element target element\n * @param {string} attribute attribute name\n * @returns {string?} attribute value\n */\nconst getAttribute = (element, attribute) => element.getAttribute(attribute);\n\n/**\n * The raw value or a given component option.\n *\n * @typedef {string | HTMLElement | Function | number | boolean | null} niceValue\n */\n\n/**\n * Utility to normalize component options\n *\n * @param {any} value the input value\n * @return {niceValue} the normalized value\n */\nfunction normalizeValue(value) {\n  if (['true', true].includes(value)) { // boolean\n  // if ('true' === value) { // boolean\n    return true;\n  }\n\n  if (['false', false].includes(value)) { // boolean\n  // if ('false' === value) { // boolean\n    return false;\n  }\n\n  if (value === '' || value === 'null') { // null\n    return null;\n  }\n\n  if (value !== '' && !Number.isNaN(+value)) { // number\n    return +value;\n  }\n\n  // string / function / HTMLElement / object\n  return value;\n}\n\n/**\n * Shortcut for `Object.keys()` static method.\n * @param  {Record<string, any>} obj a target object\n * @returns {string[]}\n */\nconst ObjectKeys = (obj) => Object.keys(obj);\n\n/**\n * Shortcut for `String.toLowerCase()`.\n *\n * @param {string} source input string\n * @returns {string} lowercase output string\n */\nconst toLowerCase = (source) => source.toLowerCase();\n\n/**\n * Utility to normalize component options.\n *\n * @param {HTMLElement} element target\n * @param {Record<string, any>} defaultOps component default options\n * @param {Record<string, any>} inputOps component instance options\n * @param {string=} ns component namespace\n * @return {Record<string, any>} normalized component options object\n */\nfunction normalizeOptions(element, defaultOps, inputOps, ns) {\n  const data = { ...element.dataset };\n  /** @type {Record<string, any>} */\n  const normalOps = {};\n  /** @type {Record<string, any>} */\n  const dataOps = {};\n  const title = 'title';\n\n  ObjectKeys(data).forEach((k) => {\n    const key = ns && k.includes(ns)\n      ? k.replace(ns, '').replace(/[A-Z]/, (match) => toLowerCase(match))\n      : k;\n\n    dataOps[key] = normalizeValue(data[k]);\n  });\n\n  ObjectKeys(inputOps).forEach((k) => {\n    inputOps[k] = normalizeValue(inputOps[k]);\n  });\n\n  ObjectKeys(defaultOps).forEach((k) => {\n    /* istanbul ignore else */\n    if (k in inputOps) {\n      normalOps[k] = inputOps[k];\n    } else if (k in dataOps) {\n      normalOps[k] = dataOps[k];\n    } else {\n      normalOps[k] = k === title\n        ? getAttribute(element, title)\n        : defaultOps[k];\n    }\n  });\n\n  return normalOps;\n}\n\nvar version = \"4.2.0\";\n\nconst Version = version;\n\n/* Native JavaScript for Bootstrap 5 | Base Component\n----------------------------------------------------- */\n\n/** Returns a new `BaseComponent` instance. */\nclass BaseComponent {\n  /**\n   * @param {HTMLElement | string} target `Element` or selector string\n   * @param {BSN.ComponentOptions=} config component instance options\n   */\n  constructor(target, config) {\n    const self = this;\n    const element = querySelector(target);\n\n    if (!element) {\n      throw Error(`${self.name} Error: \"${target}\" is not a valid selector.`);\n    }\n\n    /** @static @type {BSN.ComponentOptions} */\n    self.options = {};\n\n    const prevInstance = Data.get(element, self.name);\n    if (prevInstance) prevInstance.dispose();\n\n    /** @type {HTMLElement} */\n    self.element = element;\n\n    /* istanbul ignore else */\n    if (self.defaults && ObjectKeys(self.defaults).length) {\n      self.options = normalizeOptions(element, self.defaults, (config || {}), 'bs');\n    }\n\n    Data.set(element, self.name, self);\n  }\n\n  /* eslint-disable */\n  /* istanbul ignore next */\n  /** @static */\n  get version() { return Version; }\n\n  /* eslint-enable */\n  /* istanbul ignore next */\n  /** @static */\n  get name() { return this.constructor.name; }\n\n  /* istanbul ignore next */\n  /** @static */\n  get defaults() { return this.constructor.defaults; }\n\n  /**\n   * Removes component from target element;\n   */\n  dispose() {\n    const self = this;\n    Data.remove(self.element, self.name);\n    ObjectKeys(self).forEach((prop) => { self[prop] = null; });\n  }\n}\n\n/* Native JavaScript for Bootstrap 5 | Alert\n-------------------------------------------- */\n\n// ALERT PRIVATE GC\n// ================\nconst alertSelector = `.${alertString}`;\nconst alertDismissSelector = `[${dataBsDismiss}=\"${alertString}\"]`;\n\n/**\n * Static method which returns an existing `Alert` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Alert>}\n */\nconst getAlertInstance = (element) => getInstance(element, alertComponent);\n\n/**\n* An `Alert` initialization callback.\n* @type {BSN.InitCallback<Alert>}\n*/\nconst alertInitCallback = (element) => new Alert(element);\n\n// ALERT CUSTOM EVENTS\n// ===================\nconst closeAlertEvent = OriginalEvent(`close.bs.${alertString}`);\nconst closedAlertEvent = OriginalEvent(`closed.bs.${alertString}`);\n\n// ALERT EVENT HANDLER\n// ===================\n/**\n * Alert `transitionend` callback.\n * @param {Alert} self target Alert instance\n */\nfunction alertTransitionEnd(self) {\n  const { element } = self;\n  toggleAlertHandler(self);\n\n  dispatchEvent(element, closedAlertEvent);\n\n  self.dispose();\n  element.remove();\n}\n\n// ALERT PRIVATE METHOD\n// ====================\n/**\n * Toggle on / off the `click` event listener.\n * @param {Alert} self the target alert instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleAlertHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { dismiss } = self;\n  /* istanbul ignore else */\n  if (dismiss) action(dismiss, mouseclickEvent, self.close);\n}\n\n// ALERT DEFINITION\n// ================\n/** Creates a new Alert instance. */\nclass Alert extends BaseComponent {\n  /** @param {HTMLElement | string} target element or selector */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // the dismiss button\n    /** @static @type {HTMLElement?} */\n    self.dismiss = querySelector(alertDismissSelector, element);\n\n    // add event listener\n    toggleAlertHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return alertComponent; }\n  /* eslint-enable */\n\n  // ALERT PUBLIC METHODS\n  // ====================\n  /**\n   * Public method that hides the `.alert` element from the user,\n   * disposes the instance once animation is complete, then\n   * removes the element from the DOM.\n   *\n   * @param {Event=} e most likely the `click` event\n   * @this {Alert} the `Alert` instance or `EventTarget`\n   */\n  close(e) {\n    const self = e ? getAlertInstance(closest(this, alertSelector)) : this;\n    const { element } = self;\n\n    /* istanbul ignore else */\n    if (element && hasClass(element, showClass)) {\n      dispatchEvent(element, closeAlertEvent);\n      if (closeAlertEvent.defaultPrevented) return;\n\n      removeClass(element, showClass);\n\n      if (hasClass(element, fadeClass)) {\n        emulateTransitionEnd(element, () => alertTransitionEnd(self));\n      } else alertTransitionEnd(self);\n    }\n  }\n\n  /** Remove the component from target element. */\n  dispose() {\n    toggleAlertHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Alert, {\n  selector: alertSelector,\n  init: alertInitCallback,\n  getInstance: getAlertInstance,\n});\n\n/**\n * A global namespace for aria-pressed.\n * @type {string}\n */\nconst ariaPressed = 'aria-pressed';\n\n/**\n * Shortcut for `HTMLElement.setAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @param  {string} value attribute value\n * @returns {void}\n */\nconst setAttribute = (element, attribute, value) => element.setAttribute(attribute, value);\n\n/**\n * Add class to `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to add\n * @returns {void}\n */\nfunction addClass(element, classNAME) {\n  element.classList.add(classNAME);\n}\n\n/**\n * Global namespace for most components active class.\n */\nconst activeClass = 'active';\n\n/**\n * Global namespace for most components `toggle` option.\n */\nconst dataBsToggle = 'data-bs-toggle';\n\n/** @type {string} */\nconst buttonString = 'button';\n\n/** @type {string} */\nconst buttonComponent = 'Button';\n\n/* Native JavaScript for Bootstrap 5 | Button\n---------------------------------------------*/\n\n// BUTTON PRIVATE GC\n// =================\nconst buttonSelector = `[${dataBsToggle}=\"${buttonString}\"]`;\n\n/**\n * Static method which returns an existing `Button` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Button>}\n */\nconst getButtonInstance = (element) => getInstance(element, buttonComponent);\n\n/**\n * A `Button` initialization callback.\n * @type {BSN.InitCallback<Button>}\n */\nconst buttonInitCallback = (element) => new Button(element);\n\n// BUTTON PRIVATE METHOD\n// =====================\n/**\n * Toggles on/off the `click` event listener.\n * @param {Button} self the `Button` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleButtonHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, self.toggle);\n}\n\n// BUTTON DEFINITION\n// =================\n/** Creates a new `Button` instance. */\nclass Button extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually a `.btn` element\n   */\n  constructor(target) {\n    super(target);\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // set initial state\n    /** @type {boolean} */\n    self.isActive = hasClass(element, activeClass);\n    setAttribute(element, ariaPressed, `${!!self.isActive}`);\n\n    // add event listener\n    toggleButtonHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return buttonComponent; }\n  /* eslint-enable */\n\n  // BUTTON PUBLIC METHODS\n  // =====================\n  /**\n   * Toggles the state of the target button.\n   * @param {MouseEvent} e usually `click` Event object\n   */\n  toggle(e) {\n    if (e) e.preventDefault();\n    const self = e ? getButtonInstance(this) : this;\n    if (!self.element) return;\n    const { element, isActive } = self;\n\n    if (hasClass(element, 'disabled')) return;\n\n    const action = isActive ? removeClass : addClass;\n    action(element, activeClass);\n    setAttribute(element, ariaPressed, isActive ? 'false' : 'true');\n    self.isActive = hasClass(element, activeClass);\n  }\n\n  /** Removes the `Button` component from the target element. */\n  dispose() {\n    toggleButtonHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Button, {\n  selector: buttonSelector,\n  init: buttonInitCallback,\n  getInstance: getButtonInstance,\n});\n\n/**\n * A global namespace for `mouseenter` event.\n * @type {string}\n */\nconst mouseenterEvent = 'mouseenter';\n\n/**\n * A global namespace for `mouseleave` event.\n * @type {string}\n */\nconst mouseleaveEvent = 'mouseleave';\n\n/**\n * A global namespace for `keydown` event.\n * @type {string}\n */\nconst keydownEvent = 'keydown';\n\n/**\n * A global namespace for `ArrowLeft` key.\n * @type {string} e.which = 37 equivalent\n */\nconst keyArrowLeft = 'ArrowLeft';\n\n/**\n * A global namespace for `ArrowRight` key.\n * @type {string} e.which = 39 equivalent\n */\nconst keyArrowRight = 'ArrowRight';\n\n/**\n * A global namespace for `pointerdown` event.\n * @type {string}\n */\nconst pointerdownEvent = 'pointerdown';\n\n/**\n * A global namespace for `pointermove` event.\n * @type {string}\n */\nconst pointermoveEvent = 'pointermove';\n\n/**\n * A global namespace for `pointerup` event.\n * @type {string}\n */\nconst pointerupEvent = 'pointerup';\n\n/**\n * Returns the bounding client rect of a target `HTMLElement`.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element event.target\n * @param {boolean=} includeScale when *true*, the target scale is also computed\n * @returns {SHORTY.BoundingClientRect} the bounding client rect object\n */\nfunction getBoundingClientRect(element, includeScale) {\n  const {\n    width, height, top, right, bottom, left,\n  } = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    const { offsetWidth, offsetHeight } = element;\n    scaleX = offsetWidth > 0 ? Math.round(width) / offsetWidth\n      : /* istanbul ignore next */1;\n    scaleY = offsetHeight > 0 ? Math.round(height) / offsetHeight\n      : /* istanbul ignore next */1;\n  }\n\n  return {\n    width: width / scaleX,\n    height: height / scaleY,\n    top: top / scaleY,\n    right: right / scaleX,\n    bottom: bottom / scaleY,\n    left: left / scaleX,\n    x: left / scaleX,\n    y: top / scaleY,\n  };\n}\n\n/**\n * Returns the `document.documentElement` or the `<html>` element.\n *\n * @param {(Node | Window)=} node\n * @returns {HTMLHtmlElement}\n */\nfunction getDocumentElement(node) {\n  return getDocument(node).documentElement;\n}\n\n/**\n * Utility to determine if an `HTMLElement`\n * is partially visible in viewport.\n *\n * @param {HTMLElement} element target\n * @return {boolean} the query result\n */\nconst isElementInScrollRange = (element) => {\n  if (!element || !isNode(element)) return false;\n\n  const { top, bottom } = getBoundingClientRect(element);\n  const { clientHeight } = getDocumentElement(element);\n  return top <= clientHeight && bottom >= 0;\n};\n\n/**\n * Checks if a page is Right To Left.\n * @param {HTMLElement=} node the target\n * @returns {boolean} the query result\n */\nconst isRTL = (node) => getDocumentElement(node).dir === 'rtl';\n\n/**\n * A shortcut for `(document|Element).querySelectorAll`.\n *\n * @param {string} selector the input selector\n * @param {ParentNode=} parent optional node to look into\n * @return {NodeListOf<HTMLElement>} the query result\n */\nfunction querySelectorAll(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.querySelectorAll(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.getElementsByClassName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByClassName`.\n *\n * @param {string} selector the class name\n * @param {ParentNode=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement>} the 'HTMLCollection'\n */\nfunction getElementsByClassName(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.getElementsByClassName(selector);\n}\n\n/** @type {Map<HTMLElement, any>} */\nconst TimeCache = new Map();\n/**\n * An interface for one or more `TimerHandler`s per `Element`.\n * @see https://github.com/thednp/navbar.js/\n */\nconst Timer = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   * @param {HTMLElement} element target element\n   * @param {ReturnType<TimerHandler>} callback the callback\n   * @param {number} delay the execution delay\n   * @param {string=} key a unique key\n   */\n  set: (element, callback, delay, key) => {\n    if (!isHTMLElement(element)) return;\n\n    /* istanbul ignore else */\n    if (key && key.length) {\n      /* istanbul ignore else */\n      if (!TimeCache.has(element)) {\n        TimeCache.set(element, new Map());\n      }\n      const keyTimers = TimeCache.get(element);\n      keyTimers.set(key, setTimeout(callback, delay));\n    } else {\n      TimeCache.set(element, setTimeout(callback, delay));\n    }\n  },\n\n  /**\n   * Returns the timer associated with the target.\n   * @param {HTMLElement} element target element\n   * @param {string=} key a unique\n   * @returns {number?} the timer\n   */\n  get: (element, key) => {\n    if (!isHTMLElement(element)) return null;\n    const keyTimers = TimeCache.get(element);\n\n    if (key && key.length && keyTimers && keyTimers.get) {\n      return keyTimers.get(key) || /* istanbul ignore next */null;\n    }\n    return keyTimers || null;\n  },\n\n  /**\n   * Clears the element's timer.\n   * @param {HTMLElement} element target element\n   * @param {string=} key a unique key\n   */\n  clear: (element, key) => {\n    if (!isHTMLElement(element)) return;\n\n    if (key && key.length) {\n      const keyTimers = TimeCache.get(element);\n      /* istanbul ignore else */\n      if (keyTimers && keyTimers.get) {\n        clearTimeout(keyTimers.get(key));\n        keyTimers.delete(key);\n        /* istanbul ignore else */\n        if (keyTimers.size === 0) {\n          TimeCache.delete(element);\n        }\n      }\n    } else {\n      clearTimeout(TimeCache.get(element));\n      TimeCache.delete(element);\n    }\n  },\n};\n\n/**\n * Utility to force re-paint of an `HTMLElement` target.\n *\n * @param {HTMLElement} element is the target\n * @return {number} the `Element.offsetHeight` value\n */\nconst reflow = (element) => element.offsetHeight;\n\n/**\n * A global namespace for most scroll event listeners.\n * @type {Partial<AddEventListenerOptions>}\n */\nconst passiveHandler = { passive: true };\n\n/**\n * Global namespace for most components `target` option.\n */\nconst dataBsTarget = 'data-bs-target';\n\n/** @type {string} */\nconst carouselString = 'carousel';\n\n/** @type {string} */\nconst carouselComponent = 'Carousel';\n\n/**\n * Global namespace for most components `parent` option.\n */\nconst dataBsParent = 'data-bs-parent';\n\n/**\n * Global namespace for most components `container` option.\n */\nconst dataBsContainer = 'data-bs-container';\n\n/**\n * Returns the `Element` that THIS one targets\n * via `data-bs-target`, `href`, `data-bs-parent` or `data-bs-container`.\n *\n * @param {HTMLElement} element the target element\n * @returns {HTMLElement?} the query result\n */\nfunction getTargetElement(element) {\n  const targetAttr = [dataBsTarget, dataBsParent, dataBsContainer, 'href'];\n  const doc = getDocument(element);\n\n  return targetAttr.map((att) => {\n    const attValue = getAttribute(element, att);\n    if (attValue) {\n      return att === dataBsParent ? closest(element, attValue) : querySelector(attValue, doc);\n    }\n    return null;\n  }).filter((x) => x)[0];\n}\n\n/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Carousel>}\n */\nconst getCarouselInstance = (element) => getInstance(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n * @type {BSN.InitCallback<Carousel>}\n */\nconst carouselInitCallback = (element) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = OriginalEvent(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = OriginalEvent(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n * @param {Carousel} self the `Carousel` instance\n */\nfunction carouselTransitionEndHandler(self) {\n  const {\n    index, direction, element, slides, options,\n  } = self;\n\n  // discontinue disposed instances\n  /* istanbul ignore else */\n  if (self.isAnimating && getCarouselInstance(element)) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // check for element, might have been disposed\n    if (!getDocument(element).hidden && options.interval\n      && !self.isPaused) {\n      self.cycle();\n    }\n  }\n}\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement}\n */\nfunction carouselPauseHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n  /* istanbul ignore else */\n  if (self && !self.isPaused && !Timer.get(element, pausedClass)) {\n    addClass(element, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement}\n */\nfunction carouselResumeHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n  /* istanbul ignore else */\n  if (self && self.isPaused && !Timer.get(element, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselIndicatorHandler(e) {\n  e.preventDefault();\n  const indicator = this;\n  const element = closest(indicator, carouselSelector) || getTargetElement(indicator);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n\n  const newIndex = +getAttribute(indicator, dataBsSlideTo);\n\n  if (indicator && !hasClass(indicator, activeClass) // event target is not active\n    && !Number.isNaN(newIndex)) { // AND has the specific attribute\n    self.to(newIndex); // do the slide\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselControlsHandler(e) {\n  e.preventDefault();\n  const control = this;\n  const element = closest(control, carouselSelector) || getTargetElement(control);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n  const orientation = getAttribute(control, dataBsSlide);\n\n  /* istanbul ignore else */\n  if (orientation === 'next') {\n    self.next();\n  } else if (orientation === 'prev') {\n    self.prev();\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction carouselKeyHandler({ code, target }) {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)]\n    .filter((x) => isElementInScrollRange(x));\n  const self = getCarouselInstance(element);\n\n  /* istanbul ignore next */\n  if (!self || self.isAnimating || /textarea|input/i.test(target.tagName)) return;\n  const RTL = isRTL(element);\n  const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n  const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n  /* istanbul ignore else */\n  if (code === arrowKeyPrev) self.prev();\n  else if (code === arrowKeyNext) self.next();\n}\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n * @param {PointerEvent} e the `Event` object\n */\nfunction carouselPointerDownHandler(e) {\n  const element = this;\n  const { target } = e;\n  const self = getCarouselInstance(element);\n\n  // filter pointer event on controls & indicators\n  const { controls, indicators } = self;\n  if ([...controls, ...indicators].some((el) => (el === target || el.contains(target)))) {\n    return;\n  }\n\n  if (!self || self.isAnimating || self.isTouch) { return; }\n\n  startX = e.pageX;\n\n  /* istanbul ignore else */\n  if (element.contains(target)) {\n    self.isTouch = true;\n    toggleCarouselTouchHandlers(self, true);\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n * @param {PointerEvent} e\n */\nfunction carouselPointerMoveHandler(e) {\n  // const self = getCarouselInstance(this);\n\n  // if (!self || !self.isTouch) { return; }\n\n  currentX = e.pageX;\n}\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n\n * @param {PointerEvent} e\n */\nfunction carouselPointerUpHandler(e) {\n  const { target } = e;\n  const doc = getDocument(target);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map((c) => getCarouselInstance(c)).find((i) => i.isTouch);\n\n  // impossible to satisfy\n  /* istanbul ignore next */\n  if (!self) { return; }\n\n  const { element, index } = self;\n  const RTL = isRTL(target);\n\n  self.isTouch = false;\n  toggleCarouselTouchHandlers(self);\n\n  if (doc.getSelection().toString().length) {\n    // reset pointer position\n    startX = 0; currentX = 0; endX = 0;\n    return;\n  }\n\n  endX = e.pageX;\n\n  // the event target is outside the carousel context\n  // OR swipe distance is less than 120px\n  /* istanbul ignore else */\n  if (!element.contains(target) || Math.abs(startX - endX) < 120) {\n    // reset pointer position\n    startX = 0; currentX = 0; endX = 0;\n    return;\n  }\n  // OR determine next index to slide to\n  /* istanbul ignore else */\n  if (currentX < startX) {\n    self.to(index + (RTL ? -1 : 1));\n  } else if (currentX > startX) {\n    self.to(index + (RTL ? 1 : -1));\n  }\n  // reset pointer position\n  startX = 0; currentX = 0; endX = 0;\n}\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {number} pageIndex the index of the new active indicator\n */\nfunction activateCarouselIndicator(self, pageIndex) {\n  const { indicators } = self;\n  [...indicators].forEach((x) => removeClass(x, activeClass));\n\n  /* istanbul ignore else */\n  if (self.indicators[pageIndex]) addClass(indicators[pageIndex], activeClass);\n}\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselTouchHandlers(self, add) {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(getDocument(element), pointermoveEvent, carouselPointerMoveHandler, passiveHandler);\n  action(getDocument(element), pointerupEvent, carouselPointerUpHandler, passiveHandler);\n}\n\n/**\n * Toggles all event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselHandlers(self, add) {\n  const {\n    element, options, slides, controls, indicators,\n  } = self;\n  const {\n    touch, pause, interval, keyboard,\n  } = options;\n  const action = add ? addListener : removeListener;\n\n  if (pause && interval) {\n    action(element, mouseenterEvent, carouselPauseHandler);\n    action(element, mouseleaveEvent, carouselResumeHandler);\n  }\n\n  if (touch && slides.length > 2) {\n    action(element, pointerdownEvent, carouselPointerDownHandler, passiveHandler);\n  }\n\n  /* istanbul ignore else */\n  if (controls.length) {\n    controls.forEach((arrow) => {\n      /* istanbul ignore else */\n      if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler);\n    });\n  }\n\n  /* istanbul ignore else */\n  if (indicators.length) {\n    indicators.forEach((indicator) => {\n      action(indicator, mouseclickEvent, carouselIndicatorHandler);\n    });\n  }\n\n  if (keyboard) action(getDocument(element), keydownEvent, carouselKeyHandler);\n}\n\n/**\n * Returns the index of the current active item.\n * @param {Carousel} self the `Carousel` instance\n * @returns {number} the query result\n */\nfunction getActiveIndex(self) {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return [...slides].indexOf(activeItem);\n}\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nclass Carousel extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target mostly a `.carousel` element\n   * @param {BSN.Options.Carousel=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n    // initialization element\n    const { element } = self;\n\n    // additional properties\n    /** @type {string} */\n    self.direction = isRTL(element) ? 'right' : 'left';\n    /** @type {number} */\n    self.index = 0;\n    /** @type {boolean} */\n    self.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    self.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = self;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length < 2) { return; }\n    // external controls must be within same document context\n    const doc = getDocument(element);\n\n    self.controls = [\n      ...querySelectorAll(`[${dataBsSlide}]`, element),\n      ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    /** @type {HTMLElement?} */\n    self.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n    // a LIVE collection is prefferable\n    /** @type {HTMLElement[]} */\n    self.indicators = [\n      ...(self.indicator ? querySelectorAll(`[${dataBsSlideTo}]`, self.indicator) : []),\n      ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    // set JavaScript and DATA API options\n    const { options } = self;\n\n    // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n    self.options.interval = options.interval === true\n      ? carouselDefaults.interval\n      : options.interval;\n\n    // set first slide active if none\n    /* istanbul ignore else */\n    if (getActiveIndex(self) < 0) {\n      addClass(slides[0], activeClass);\n      /* istanbul ignore else */\n      if (self.indicators.length) activateCarouselIndicator(self, 0);\n    }\n\n    // attach event handlers\n    toggleCarouselHandlers(self, true);\n\n    // start to cycle if interval is set\n    if (options.interval) self.cycle();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return carouselComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return carouselDefaults; }\n  /* eslint-enable */\n\n  /**\n   * Check if instance is paused.\n   * @returns {boolean}\n  */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   * @returns {boolean}\n  */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const self = this;\n    const {\n      element, options, isPaused, index,\n    } = self;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(element, () => {\n      // it's very important to check self.element\n      // where instance might have been disposed\n      /* istanbul ignore else */\n      if (self.element && !self.isPaused && !self.isTouch\n        && isElementInScrollRange(element)) {\n        self.to(index + 1);\n      }\n    }, options.interval, carouselString);\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const self = this;\n    const { element, options } = self;\n    /* istanbul ignore else */\n    if (!self.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(element, () => {}, 1, pausedClass);\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    const self = this;\n    /* istanbul ignore else */\n    if (!self.isAnimating) { self.to(self.index + 1); }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    const self = this;\n    /* istanbul ignore else */\n    if (!self.isAnimating) { self.to(self.index - 1); }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   * @param {number} idx the index of the item to jump to\n   */\n  to(idx) {\n    const self = this;\n    const {\n      element, slides, options,\n    } = self;\n    const activeItem = getActiveIndex(self);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (self.isAnimating || activeItem === next || Timer.get(element, dataBsSlide)) return;\n\n    // determine transition direction\n    /* istanbul ignore else */\n    if ((activeItem < next) || (activeItem === 0 && next === slides.length - 1)) {\n      self.direction = RTL ? 'right' : 'left'; // next\n    } else if ((activeItem > next) || (activeItem === slides.length - 1 && next === 0)) {\n      self.direction = RTL ? 'left' : 'right'; // prev\n    }\n    const { direction } = self;\n\n    // find the right next index\n    if (next < 0) { next = slides.length - 1; } else if (next >= slides.length) { next = 0; }\n\n    // orientation, class name, eventProperties\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    const eventProperties = {\n      relatedTarget: slides[next],\n      from: activeItem,\n      to: next,\n      direction,\n    };\n\n    // update event properties\n    ObjectAssign(carouselSlideEvent, eventProperties);\n    ObjectAssign(carouselSlidEvent, eventProperties);\n\n    // discontinue when prevented\n    dispatchEvent(element, carouselSlideEvent);\n    if (carouselSlideEvent.defaultPrevented) return;\n\n    // update index\n    self.index = next;\n    activateCarouselIndicator(self, next);\n\n    if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n      Timer.set(element, () => {\n        addClass(slides[next], `${carouselItem}-${orientation}`);\n        reflow(slides[next]);\n        addClass(slides[next], `${carouselItem}-${directionClass}`);\n        addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n        emulateTransitionEnd(slides[next], () => carouselTransitionEndHandler(self));\n      }, 0, dataBsSlide);\n    } else {\n      addClass(slides[next], activeClass);\n      removeClass(slides[activeItem], activeClass);\n\n      Timer.set(element, () => {\n        Timer.clear(element, dataBsSlide);\n        // check for element, might have been disposed\n        /* istanbul ignore else */\n        if (element && options.interval && !self.isPaused) {\n          self.cycle();\n        }\n\n        dispatchEvent(element, carouselSlidEvent);\n      }, 0, dataBsSlide);\n    }\n  }\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const self = this;\n    const { slides } = self;\n    const itemClasses = ['start', 'end', 'prev', 'next'];\n\n    [...slides].forEach((slide, idx) => {\n      if (hasClass(slide, activeClass)) activateCarouselIndicator(self, idx);\n      itemClasses.forEach((c) => removeClass(slide, `${carouselItem}-${c}`));\n    });\n\n    toggleCarouselHandlers(self);\n    super.dispose();\n  }\n}\n\nObjectAssign(Carousel, {\n  selector: carouselSelector,\n  init: carouselInitCallback,\n  getInstance: getCarouselInstance,\n});\n\n/**\n * A global namespace for aria-expanded.\n * @type {string}\n */\nconst ariaExpanded = 'aria-expanded';\n\n/**\n * Shortcut for `Object.entries()` static method.\n * @param  {Record<string, any>} obj a target object\n * @returns {[string, any][]}\n */\nconst ObjectEntries = (obj) => Object.entries(obj);\n\n/**\n * Shortcut for multiple uses of `HTMLElement.style.propertyName` method.\n * @param  {HTMLElement} element target element\n * @param  {Partial<CSSStyleDeclaration>} styles attribute value\n */\nconst setElementStyle = (element, styles) => {\n  ObjectEntries(styles).forEach(([key, value]) => {\n    if (key.includes('--')) {\n      element.style.setProperty(key, value);\n    } else {\n      const propObject = {}; propObject[key] = value;\n      ObjectAssign(element.style, propObject);\n    }\n  });\n};\n\n/**\n * Global namespace for most components `collapsing` class.\n * As used by `Collapse` / `Tab`.\n */\nconst collapsingClass = 'collapsing';\n\n/** @type {string} */\nconst collapseString = 'collapse';\n\n/** @type {string} */\nconst collapseComponent = 'Collapse';\n\n/* Native JavaScript for Bootstrap 5 | Collapse\n----------------------------------------------- */\n\n// COLLAPSE GC\n// ===========\nconst collapseSelector = `.${collapseString}`;\nconst collapseToggleSelector = `[${dataBsToggle}=\"${collapseString}\"]`;\nconst collapseDefaults = { parent: null };\n\n/**\n * Static method which returns an existing `Collapse` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Collapse>}\n */\nconst getCollapseInstance = (element) => getInstance(element, collapseComponent);\n\n/**\n * A `Collapse` initialization callback.\n * @type {BSN.InitCallback<Collapse>}\n */\nconst collapseInitCallback = (element) => new Collapse(element);\n\n// COLLAPSE CUSTOM EVENTS\n// ======================\nconst showCollapseEvent = OriginalEvent(`show.bs.${collapseString}`);\nconst shownCollapseEvent = OriginalEvent(`shown.bs.${collapseString}`);\nconst hideCollapseEvent = OriginalEvent(`hide.bs.${collapseString}`);\nconst hiddenCollapseEvent = OriginalEvent(`hidden.bs.${collapseString}`);\n\n// COLLAPSE PRIVATE METHODS\n// ========================\n/**\n * Expand the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction expandCollapse(self) {\n  const {\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, showCollapseEvent);\n  if (showCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  addClass(element, collapsingClass);\n  removeClass(element, collapseString);\n\n  setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'true'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n    addClass(element, showClass);\n\n    setElementStyle(element, { height: '' });\n\n    dispatchEvent(element, shownCollapseEvent);\n  });\n}\n\n/**\n * Collapse the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction collapseContent(self) {\n  const {\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, hideCollapseEvent);\n\n  if (hideCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n  removeClass(element, collapseString);\n  removeClass(element, showClass);\n  addClass(element, collapsingClass);\n\n  reflow(element);\n  setElementStyle(element, { height: '0px' });\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    /* istanbul ignore else */\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'false'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n\n    setElementStyle(element, { height: '' });\n\n    dispatchEvent(element, hiddenCollapseEvent);\n  });\n}\n\n/**\n * Toggles on/off the event listener(s) of the `Collapse` instance.\n * @param {Collapse} self the `Collapse` instance\n * @param {boolean=} add when `true`, the event listener is added\n */\nfunction toggleCollapseHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, collapseClickHandler));\n  }\n}\n\n// COLLAPSE EVENT HANDLER\n// ======================\n/**\n * Handles the `click` event for the `Collapse` instance.\n * @param {MouseEvent} e the `Event` object\n */\nfunction collapseClickHandler(e) {\n  const { target } = e; // our target is `HTMLElement`\n  const trigger = target && closest(target, collapseToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getCollapseInstance(element);\n  /* istanbul ignore else */\n  if (self) self.toggle();\n\n  // event target is anchor link #398\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n// COLLAPSE DEFINITION\n// ===================\n\n/** Returns a new `Colapse` instance. */\nclass Collapse extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target and `Element` that matches the selector\n   * @param {BSN.Options.Collapse=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element, options } = self;\n    const doc = getDocument(element);\n\n    // set triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(collapseToggleSelector, doc)]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // set parent accordion\n    /** @type {HTMLElement?} */\n    self.parent = querySelector(options.parent, doc)\n      || getTargetElement(element) || null;\n\n    // add event listeners\n    toggleCollapseHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return collapseComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return collapseDefaults; }\n  /* eslint-enable */\n\n  // COLLAPSE PUBLIC METHODS\n  // =======================\n  /** Toggles the visibility of the collapse. */\n  toggle() {\n    const self = this;\n    if (!hasClass(self.element, showClass)) self.show();\n    else self.hide();\n  }\n\n  /** Hides the collapse. */\n  hide() {\n    const self = this;\n    const { triggers, element } = self;\n    if (Timer.get(element)) return;\n\n    collapseContent(self);\n    /* istanbul ignore else */\n    if (triggers.length) {\n      triggers.forEach((btn) => addClass(btn, `${collapseString}d`));\n    }\n  }\n\n  /** Shows the collapse. */\n  show() {\n    const self = this;\n    const {\n      element, parent, triggers,\n    } = self;\n    let activeCollapse;\n    let activeCollapseInstance;\n\n    if (parent) {\n      activeCollapse = [...querySelectorAll(`.${collapseString}.${showClass}`, parent)]\n        .find((i) => getCollapseInstance(i));\n      activeCollapseInstance = activeCollapse && getCollapseInstance(activeCollapse);\n    }\n\n    if ((!parent || !Timer.get(parent)) && !Timer.get(element)) {\n      if (activeCollapseInstance && activeCollapse !== element) {\n        collapseContent(activeCollapseInstance);\n        activeCollapseInstance.triggers.forEach((btn) => {\n          addClass(btn, `${collapseString}d`);\n        });\n      }\n\n      expandCollapse(self);\n      /* istanbul ignore else */\n      if (triggers.length) {\n        triggers.forEach((btn) => removeClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Remove the `Collapse` component from the target `Element`. */\n  dispose() {\n    const self = this;\n    toggleCollapseHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Collapse, {\n  selector: collapseSelector,\n  init: collapseInitCallback,\n  getInstance: getCollapseInstance,\n});\n\n/**\n * A global namespace for `focus` event.\n * @type {string}\n */\nconst focusEvent = 'focus';\n\n/**\n * A global namespace for `keyup` event.\n * @type {string}\n */\nconst keyupEvent = 'keyup';\n\n/**\n * A global namespace for `scroll` event.\n * @type {string}\n */\nconst scrollEvent = 'scroll';\n\n/**\n * A global namespace for `resize` event.\n * @type {string}\n */\nconst resizeEvent = 'resize';\n\n/**\n * A global namespace for `ArrowUp` key.\n * @type {string} e.which = 38 equivalent\n */\nconst keyArrowUp = 'ArrowUp';\n\n/**\n * A global namespace for `ArrowDown` key.\n * @type {string} e.which = 40 equivalent\n */\nconst keyArrowDown = 'ArrowDown';\n\n/**\n * A global namespace for `Escape` key.\n * @type {string} e.which = 27 equivalent\n */\nconst keyEscape = 'Escape';\n\n/**\n * Shortcut for `HTMLElement.hasAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @returns {boolean} the query result\n */\nconst hasAttribute = (element, attribute) => element.hasAttribute(attribute);\n\n/**\n * Utility to focus an `HTMLElement` target.\n *\n * @param {HTMLElement} element is the target\n */\nconst focus = (element) => element.focus();\n\n/**\n * Returns the `Window` object of a target node.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {(Node | Window)=} node target node\n * @returns {Window} the `Window` object\n */\nfunction getWindow(node) {\n  // node is undefined | NULL\n  if (!node) return window;\n  // node instanceof Document\n  if (isDocument(node)) return node.defaultView;\n  // node instanceof Node\n  if (isNode(node)) return node.ownerDocument.defaultView;\n  // node is instanceof Window\n  return node;\n}\n\n/**\n * Global namespace for `Dropdown` types / classes.\n */\nconst dropdownMenuClasses = ['dropdown', 'dropup', 'dropstart', 'dropend'];\n\n/** @type {string} */\nconst dropdownComponent = 'Dropdown';\n\n/**\n * Global namespace for `.dropdown-menu`.\n */\nconst dropdownMenuClass = 'dropdown-menu';\n\n/**\n * Checks if an *event.target* or its parent has an `href=\"#\"` value.\n * We need to prevent jumping around onclick, don't we?\n *\n * @param {Node} element the target element\n * @returns {boolean} the query result\n */\nfunction isEmptyAnchor(element) {\n  // `EventTarget` must be `HTMLElement`\n  const parentAnchor = closest(element, 'A');\n  return isHTMLElement(element)\n    // anchor href starts with #\n    && ((hasAttribute(element, 'href') && element.href.slice(-1) === '#')\n    // OR a child of an anchor with href starts with #\n    || (parentAnchor && hasAttribute(parentAnchor, 'href')\n    && parentAnchor.href.slice(-1) === '#'));\n}\n\n/* Native JavaScript for Bootstrap 5 | Dropdown\n----------------------------------------------- */\n\n// DROPDOWN PRIVATE GC\n// ===================\nconst [\n  dropdownString,\n  dropupString,\n  dropstartString,\n  dropendString,\n] = dropdownMenuClasses;\nconst dropdownSelector = `[${dataBsToggle}=\"${dropdownString}\"]`;\n\n/**\n * Static method which returns an existing `Dropdown` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Dropdown>}\n */\nconst getDropdownInstance = (element) => getInstance(element, dropdownComponent);\n\n/**\n * A `Dropdown` initialization callback.\n * @type {BSN.InitCallback<Dropdown>}\n */\nconst dropdownInitCallback = (element) => new Dropdown(element);\n\n// DROPDOWN PRIVATE GC\n// ===================\n// const dropdownMenuStartClass = `${dropdownMenuClass}-start`;\nconst dropdownMenuEndClass = `${dropdownMenuClass}-end`;\nconst verticalClass = [dropdownString, dropupString];\nconst horizontalClass = [dropstartString, dropendString];\nconst menuFocusTags = ['A', 'BUTTON'];\n\nconst dropdownDefaults = {\n  offset: 5, // [number] 5(px)\n  display: 'dynamic', // [dynamic|static]\n};\n\n// DROPDOWN CUSTOM EVENTS\n// ======================\nconst showDropdownEvent = OriginalEvent(`show.bs.${dropdownString}`);\nconst shownDropdownEvent = OriginalEvent(`shown.bs.${dropdownString}`);\nconst hideDropdownEvent = OriginalEvent(`hide.bs.${dropdownString}`);\nconst hiddenDropdownEvent = OriginalEvent(`hidden.bs.${dropdownString}`);\n\n// DROPDOWN PRIVATE METHODS\n// ========================\n/**\n * Apply specific style or class names to a `.dropdown-menu` to automatically\n * accomodate the layout and the page scroll.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction styleDropdown(self) {\n  const {\n    element, menu, parentElement, options,\n  } = self;\n  const { offset } = options;\n\n  // don't apply any style on mobile view\n  /* istanbul ignore next: this test requires a navbar */\n  if (getElementStyle(menu, 'position') === 'static') return;\n\n  const RTL = isRTL(element);\n  // const menuStart = hasClass(menu, dropdownMenuStartClass);\n  const menuEnd = hasClass(menu, dropdownMenuEndClass);\n\n  // reset menu offset and position\n  const resetProps = ['margin', 'top', 'bottom', 'left', 'right'];\n  resetProps.forEach((p) => { menu.style[p] = ''; });\n\n  // set initial position class\n  // take into account .btn-group parent as .dropdown\n  // this requires navbar/btn-group/input-group\n  let positionClass = dropdownMenuClasses.find((c) => hasClass(parentElement, c))\n    || /* istanbul ignore next: fallback position */ dropdownString;\n\n  /** @type {Record<string, Record<string, any>>} */\n  let dropdownMargin = {\n    dropdown: [offset, 0, 0],\n    dropup: [0, 0, offset],\n    dropstart: RTL ? [-1, 0, 0, offset] : [-1, offset, 0],\n    dropend: RTL ? [-1, offset, 0] : [-1, 0, 0, offset],\n  };\n\n  /** @type {Record<string, Record<string, any>>} */\n  const dropdownPosition = {\n    dropdown: { top: '100%' },\n    dropup: { top: 'auto', bottom: '100%' },\n    dropstart: RTL ? { left: '100%', right: 'auto' } : { left: 'auto', right: '100%' },\n    dropend: RTL ? { left: 'auto', right: '100%' } : { left: '100%', right: 'auto' },\n    menuStart: RTL ? { right: 0, left: 'auto' } : { right: 'auto', left: 0 },\n    menuEnd: RTL ? { right: 'auto', left: 0 } : { right: 0, left: 'auto' },\n  };\n\n  const { offsetWidth: menuWidth, offsetHeight: menuHeight } = menu;\n\n  const { clientWidth, clientHeight } = getDocumentElement(element);\n  const {\n    left: targetLeft, top: targetTop,\n    width: targetWidth, height: targetHeight,\n  } = getBoundingClientRect(element);\n\n  // dropstart | dropend\n  const leftFullExceed = targetLeft - menuWidth - offset < 0;\n  // dropend\n  const rightFullExceed = targetLeft + menuWidth + targetWidth + offset >= clientWidth;\n  // dropstart | dropend\n  const bottomExceed = targetTop + menuHeight + offset >= clientHeight;\n  // dropdown\n  const bottomFullExceed = targetTop + menuHeight + targetHeight + offset >= clientHeight;\n  // dropup\n  const topExceed = targetTop - menuHeight - offset < 0;\n  // dropdown / dropup\n  const leftExceed = ((!RTL && menuEnd) || (RTL && !menuEnd))\n    && targetLeft + targetWidth - menuWidth < 0;\n  const rightExceed = ((RTL && menuEnd) || (!RTL && !menuEnd))\n    && targetLeft + menuWidth >= clientWidth;\n\n  // recompute position\n  // handle RTL as well\n  if (horizontalClass.includes(positionClass) && leftFullExceed && rightFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropstartString && (!RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropendString;\n  }\n  if (positionClass === dropendString && (RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropstartString;\n  }\n  if (positionClass === dropupString && topExceed && !bottomFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropdownString && bottomFullExceed && !topExceed) {\n    positionClass = dropupString;\n  }\n\n  // override position for horizontal classes\n  if (horizontalClass.includes(positionClass) && bottomExceed) {\n    ObjectAssign(dropdownPosition[positionClass], {\n      top: 'auto', bottom: 0,\n    });\n  }\n\n  // override position for vertical classes\n  if (verticalClass.includes(positionClass) && (leftExceed || rightExceed)) {\n    // don't realign when menu is wider than window\n    // in both RTL and non-RTL readability is KING\n    let posAjust;\n    if (!leftExceed && rightExceed && !RTL) posAjust = { left: 'auto', right: 0 };\n    if (leftExceed && !rightExceed && RTL) posAjust = { left: 0, right: 'auto' };\n    if (posAjust) ObjectAssign(dropdownPosition[positionClass], posAjust);\n  }\n\n  dropdownMargin = dropdownMargin[positionClass];\n  setElementStyle(menu, {\n    ...dropdownPosition[positionClass],\n    margin: `${dropdownMargin.map((x) => (x ? `${x}px` : x)).join(' ')}`,\n  });\n\n  // override dropdown-menu-start | dropdown-menu-end\n  if (verticalClass.includes(positionClass) && menuEnd) {\n    /* istanbul ignore else */\n    if (menuEnd) {\n      const endAdjust = (!RTL && leftExceed) || (RTL && rightExceed)\n        ? 'menuStart' : /* istanbul ignore next */'menuEnd';\n      setElementStyle(menu, dropdownPosition[endAdjust]);\n    }\n  }\n}\n\n/**\n * Returns an `Array` of focusable items in the given dropdown-menu.\n * @param {HTMLElement} menu\n * @returns {HTMLElement[]}\n */\nfunction getMenuItems(menu) {\n  return [...menu.children].map((c) => {\n    if (c && menuFocusTags.includes(c.tagName)) return c;\n    const { firstElementChild } = c;\n    if (firstElementChild && menuFocusTags.includes(firstElementChild.tagName)) {\n      return firstElementChild;\n    }\n    return null;\n  }).filter((c) => c);\n}\n\n/**\n * Toggles on/off the listeners for the events that close the dropdown\n * as well as event that request a new position for the dropdown.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction toggleDropdownDismiss(self) {\n  const { element, options } = self;\n  const action = self.open ? addListener : removeListener;\n  const doc = getDocument(element);\n\n  action(doc, mouseclickEvent, dropdownDismissHandler);\n  action(doc, focusEvent, dropdownDismissHandler);\n  action(doc, keydownEvent, dropdownPreventScroll);\n  action(doc, keyupEvent, dropdownKeyHandler);\n\n  /* istanbul ignore else */\n  if (options.display === 'dynamic') {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      action(getWindow(element), ev, dropdownLayoutHandler, passiveHandler);\n    });\n  }\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Dropdown`.\n *\n * @param {Dropdown} self the `Dropdown` instance\n * @param {boolean=} add when `true`, it will add the event listener\n */\nfunction toggleDropdownHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, dropdownClickHandler);\n}\n\n/**\n * Returns the currently open `.dropdown` element.\n *\n * @param {(Node | Window)=} element target\n * @returns {HTMLElement?} the query result\n */\nfunction getCurrentOpenDropdown(element) {\n  const currentParent = [...dropdownMenuClasses, 'btn-group', 'input-group']\n    .map((c) => getElementsByClassName(`${c} ${showClass}`, getDocument(element)))\n    .find((x) => x.length);\n\n  if (currentParent && currentParent.length) {\n    return [...currentParent[0].children]\n      .find((x) => hasAttribute(x, dataBsToggle));\n  }\n  return null;\n}\n\n// DROPDOWN EVENT HANDLERS\n// =======================\n/**\n * Handles the `click` event for the `Dropdown` instance.\n *\n * @param {MouseEvent} e event object\n * @this {Document}\n */\nfunction dropdownDismissHandler(e) {\n  const { target, type } = e;\n\n  /* istanbul ignore next: impossible to satisfy */\n  if (!target || !target.closest) return; // some weird FF bug #409\n\n  const element = getCurrentOpenDropdown(target);\n  const self = getDropdownInstance(element);\n\n  /* istanbul ignore next */\n  if (!self) return;\n\n  const { parentElement, menu } = self;\n\n  const hasData = closest(target, dropdownSelector) !== null;\n  const isForm = parentElement && parentElement.contains(target)\n    && (target.tagName === 'form' || closest(target, 'form') !== null);\n\n  if (type === mouseclickEvent && isEmptyAnchor(target)) {\n    e.preventDefault();\n  }\n  if (type === focusEvent\n    && (target === element || target === menu || menu.contains(target))) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (isForm || hasData) ; else if (self) {\n    self.hide();\n  }\n}\n\n/**\n * Handles `click` event listener for `Dropdown`.\n * @this {HTMLElement}\n * @param {MouseEvent} e event object\n */\nfunction dropdownClickHandler(e) {\n  const element = this;\n  const { target } = e;\n  const self = getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.toggle();\n    /* istanbul ignore else */\n    if (target && isEmptyAnchor(target)) e.preventDefault();\n  }\n}\n\n/**\n * Prevents scroll when dropdown-menu is visible.\n * @param {KeyboardEvent} e event object\n */\nfunction dropdownPreventScroll(e) {\n  /* istanbul ignore else */\n  if ([keyArrowDown, keyArrowUp].includes(e.code)) e.preventDefault();\n}\n\n/**\n * Handles keyboard `keydown` events for `Dropdown`.\n * @param {KeyboardEvent} e keyboard key\n * @this {Document}\n */\nfunction dropdownKeyHandler(e) {\n  const { code } = e;\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n  const { activeElement } = element && getDocument(element);\n  /* istanbul ignore next: impossible to satisfy */\n  if (!self || !activeElement) return;\n  const { menu, open } = self;\n  const menuItems = getMenuItems(menu);\n\n  // arrow up & down\n  if (menuItems && menuItems.length && [keyArrowDown, keyArrowUp].includes(code)) {\n    let idx = menuItems.indexOf(activeElement);\n    /* istanbul ignore else */\n    if (activeElement === element) {\n      idx = 0;\n    } else if (code === keyArrowUp) {\n      idx = idx > 1 ? idx - 1 : 0;\n    } else if (code === keyArrowDown) {\n      idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n    }\n    /* istanbul ignore else */\n    if (menuItems[idx]) focus(menuItems[idx]);\n  }\n\n  if (keyEscape === code && open) {\n    self.toggle();\n    focus(element);\n  }\n}\n\n/**\n * @this {globalThis}\n * @returns {void}\n */\nfunction dropdownLayoutHandler() {\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self && self.open) styleDropdown(self);\n}\n\n// DROPDOWN DEFINITION\n// ===================\n/** Returns a new Dropdown instance. */\nclass Dropdown extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target Element or string selector\n   * @param {BSN.Options.Dropdown=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const { parentElement } = element;\n\n    // set targets\n    /** @type {(Element | HTMLElement)} */\n    self.parentElement = parentElement;\n    /** @type {(Element | HTMLElement)} */\n    self.menu = querySelector(`.${dropdownMenuClass}`, parentElement);\n\n    // set initial state to closed\n    /** @type {boolean} */\n    self.open = false;\n\n    // add event listener\n    toggleDropdownHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return dropdownComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return dropdownDefaults; }\n  /* eslint-enable */\n\n  // DROPDOWN PUBLIC METHODS\n  // =======================\n  /** Shows/hides the dropdown menu to the user. */\n  toggle() {\n    const self = this;\n\n    if (self.open) self.hide();\n    else self.show();\n  }\n\n  /** Shows the dropdown menu to the user. */\n  show() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n\n    /* istanbul ignore next */\n    if (open) return;\n\n    const currentElement = getCurrentOpenDropdown(element);\n    const currentInstance = currentElement && getDropdownInstance(currentElement);\n    if (currentInstance) currentInstance.hide();\n\n    // dispatch event\n    [showDropdownEvent, shownDropdownEvent].forEach((e) => {\n      e.relatedTarget = element;\n    });\n    dispatchEvent(parentElement, showDropdownEvent);\n    if (showDropdownEvent.defaultPrevented) return;\n\n    addClass(menu, showClass);\n    addClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'true');\n\n    // change menu position\n    styleDropdown(self);\n\n    self.open = !open;\n\n    focus(element); // focus the element\n    toggleDropdownDismiss(self);\n    dispatchEvent(parentElement, shownDropdownEvent);\n  }\n\n  /** Hides the dropdown menu from the user. */\n  hide() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n\n    /* istanbul ignore next */\n    if (!open) return;\n\n    [hideDropdownEvent, hiddenDropdownEvent].forEach((e) => {\n      e.relatedTarget = element;\n    });\n    dispatchEvent(parentElement, hideDropdownEvent);\n    if (hideDropdownEvent.defaultPrevented) return;\n\n    removeClass(menu, showClass);\n    removeClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'false');\n\n    self.open = !open;\n    // only re-attach handler if the instance is not disposed\n    toggleDropdownDismiss(self);\n    dispatchEvent(parentElement, hiddenDropdownEvent);\n  }\n\n  /** Removes the `Dropdown` component from the target element. */\n  dispose() {\n    const self = this;\n    if (self.open) self.hide();\n\n    toggleDropdownHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Dropdown, {\n  selector: dropdownSelector,\n  init: dropdownInitCallback,\n  getInstance: getDropdownInstance,\n});\n\n/**\n * A global namespace for aria-hidden.\n * @type {string}\n */\nconst ariaHidden = 'aria-hidden';\n\n/**\n * A global namespace for aria-modal.\n * @type {string}\n */\nconst ariaModal = 'aria-modal';\n\n/**\n * Shortcut for `HTMLElement.removeAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @returns {void}\n */\nconst removeAttribute = (element, attribute) => element.removeAttribute(attribute);\n\n/**\n * Returns the `document.body` or the `<body>` element.\n *\n * @param {(Node | Window)=} node\n * @returns {HTMLBodyElement}\n */\nfunction getDocumentBody(node) {\n  return getDocument(node).body;\n}\n\n/** @type {string} */\nconst modalString = 'modal';\n\n/** @type {string} */\nconst modalComponent = 'Modal';\n\n/**\n * Check if target is a `ShadowRoot`.\n *\n * @param {any} element target\n * @returns {boolean} the query result\n */\nconst isShadowRoot = (element) => (element && element.constructor.name === 'ShadowRoot')\n  || false;\n\n/**\n * Returns the `parentNode` also going through `ShadowRoot`.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {Node} node the target node\n * @returns {Node} the apropriate parent node\n */\nfunction getParentNode(node) {\n  if (node.nodeName === 'HTML') {\n    return node;\n  }\n\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  return (\n    node.assignedSlot // step into the shadow DOM of the parent of a slotted node\n    || node.parentNode // DOM Element detected\n    || (isShadowRoot(node) && node.host) // ShadowRoot detected\n    || getDocumentElement(node) // fallback\n  );\n}\n\n/**\n * Check if a target element is a `<table>`, `<td>` or `<th>`.\n * This specific check is important for determining\n * the `offsetParent` of a given element.\n *\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\nconst isTableElement = (element) => (element && ['TABLE', 'TD', 'TH'].includes(element.tagName))\n  || false;\n\n/**\n * Returns an `HTMLElement` to be used as default value for *options.container*\n * for `Tooltip` / `Popover` components.\n *\n * When `getOffset` is *true*, it returns the `offsetParent` for tooltip/popover\n * offsets computation similar to **floating-ui**.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element the target\n * @param {boolean=} getOffset when *true* it will return an `offsetParent`\n * @returns {ParentNode | Window} the query result\n */\nfunction getElementContainer(element, getOffset) {\n  const majorBlockTags = ['HTML', 'BODY'];\n\n  if (getOffset) {\n    /** @type {any} */\n    let { offsetParent } = element;\n    const win = getWindow(element);\n\n    while (offsetParent && (isTableElement(offsetParent)\n      || (isHTMLElement(offsetParent)\n        // we must count for both fixed & sticky\n        && !['sticky', 'fixed'].includes(getElementStyle(offsetParent, 'position'))))) {\n      offsetParent = offsetParent.offsetParent;\n    }\n\n    if (!offsetParent || (majorBlockTags.includes(offsetParent.tagName)\n        || getElementStyle(offsetParent, 'position') === 'static')) {\n      offsetParent = win;\n    }\n    return offsetParent;\n  }\n\n  /** @type {ParentNode[]} */\n  const containers = [];\n  /** @type {ParentNode} */\n  let { parentNode } = element;\n\n  while (parentNode && !majorBlockTags.includes(parentNode.nodeName)) {\n    parentNode = getParentNode(parentNode);\n    /* istanbul ignore else */\n    if (!(isShadowRoot(parentNode) || !!parentNode.shadowRoot\n      || isTableElement(parentNode))) {\n      containers.push(parentNode);\n    }\n  }\n\n  return containers.find((c, i) => {\n    if (getElementStyle(c, 'position') !== 'relative'\n      && containers.slice(i + 1).every((r) => getElementStyle(r, 'position') === 'static')) {\n      return c;\n    }\n    return null;\n  }) || getDocumentBody(element);\n}\n\n/**\n * Global namespace for components `fixed-top` class.\n */\nconst fixedTopClass = 'fixed-top';\n\n/**\n * Global namespace for components `fixed-bottom` class.\n */\nconst fixedBottomClass = 'fixed-bottom';\n\n/**\n * Global namespace for components `sticky-top` class.\n */\nconst stickyTopClass = 'sticky-top';\n\n/**\n * Global namespace for components `position-sticky` class.\n */\nconst positionStickyClass = 'position-sticky';\n\n/** @param {(HTMLElement | Document)=} parent */\nconst getFixedItems = (parent) => [\n  ...getElementsByClassName(fixedTopClass, parent),\n  ...getElementsByClassName(fixedBottomClass, parent),\n  ...getElementsByClassName(stickyTopClass, parent),\n  ...getElementsByClassName(positionStickyClass, parent),\n  ...getElementsByClassName('is-fixed', parent),\n];\n\n/**\n * Removes *padding* and *overflow* from the `<body>`\n * and all spacing from fixed items.\n * @param {HTMLElement=} element the target modal/offcanvas\n */\nfunction resetScrollbar(element) {\n  const bd = getDocumentBody(element);\n  setElementStyle(bd, {\n    paddingRight: '',\n    overflow: '',\n  });\n\n  const fixedItems = getFixedItems(bd);\n\n  if (fixedItems.length) {\n    fixedItems.forEach((fixed) => {\n      setElementStyle(fixed, {\n        paddingRight: '',\n        marginRight: '',\n      });\n    });\n  }\n}\n\n/**\n * Returns the scrollbar width if the body does overflow\n * the window.\n * @param {HTMLElement=} element\n * @returns {number} the value\n */\nfunction measureScrollbar(element) {\n  const { clientWidth } = getDocumentElement(element);\n  const { innerWidth } = getWindow(element);\n  return Math.abs(innerWidth - clientWidth);\n}\n\n/**\n * Sets the `<body>` and fixed items style when modal / offcanvas\n * is shown to the user.\n *\n * @param {HTMLElement} element the target modal/offcanvas\n * @param {boolean=} overflow body does overflow or not\n */\nfunction setScrollbar(element, overflow) {\n  const bd = getDocumentBody(element);\n  const bodyPad = parseInt(getElementStyle(bd, 'paddingRight'), 10);\n  const isOpen = getElementStyle(bd, 'overflow') === 'hidden';\n  const sbWidth = isOpen && bodyPad ? 0 : measureScrollbar(element);\n  const fixedItems = getFixedItems(bd);\n\n  /* istanbul ignore else */\n  if (overflow) {\n    setElementStyle(bd, {\n      overflow: 'hidden',\n      paddingRight: `${bodyPad + sbWidth}px`,\n    });\n\n    /* istanbul ignore else */\n    if (fixedItems.length) {\n      fixedItems.forEach((fixed) => {\n        const itemPadValue = getElementStyle(fixed, 'paddingRight');\n        fixed.style.paddingRight = `${parseInt(itemPadValue, 10) + sbWidth}px`;\n        /* istanbul ignore else */\n        if ([stickyTopClass, positionStickyClass].some((c) => hasClass(fixed, c))) {\n          const itemMValue = getElementStyle(fixed, 'marginRight');\n          fixed.style.marginRight = `${parseInt(itemMValue, 10) - sbWidth}px`;\n        }\n      });\n    }\n  }\n}\n\n/**\n * This is a shortie for `document.createElement` method\n * which allows you to create a new `HTMLElement` for a given `tagName`\n * or based on an object with specific non-readonly attributes:\n * `id`, `className`, `textContent`, `style`, etc.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\n *\n * @param {Record<string, string> | string} param `tagName` or object\n * @return {HTMLElement} a new `HTMLElement` or `Element`\n */\nfunction createElement(param) {\n  if (!param) return null;\n\n  if (typeof param === 'string') {\n    return getDocument().createElement(param);\n  }\n\n  const { tagName } = param;\n  const attr = { ...param };\n  const newElement = createElement(tagName);\n  delete attr.tagName;\n  ObjectAssign(newElement, attr);\n  return newElement;\n}\n\n/** @type {string} */\nconst offcanvasString = 'offcanvas';\n\nconst backdropString = 'backdrop';\nconst modalBackdropClass = `${modalString}-${backdropString}`;\nconst offcanvasBackdropClass = `${offcanvasString}-${backdropString}`;\nconst modalActiveSelector = `.${modalString}.${showClass}`;\nconst offcanvasActiveSelector = `.${offcanvasString}.${showClass}`;\n\n// any document would suffice\nconst overlay = createElement('div');\n\n/**\n * Returns the current active modal / offcancas element.\n * @param {HTMLElement=} element the context element\n * @returns {HTMLElement?} the requested element\n */\nfunction getCurrentOpen(element) {\n  return querySelector(`${modalActiveSelector},${offcanvasActiveSelector}`, getDocument(element));\n}\n\n/**\n * Toogles from a Modal overlay to an Offcanvas, or vice-versa.\n * @param {boolean=} isModal\n */\nfunction toggleOverlayType(isModal) {\n  const targetClass = isModal ? modalBackdropClass : offcanvasBackdropClass;\n  [modalBackdropClass, offcanvasBackdropClass].forEach((c) => {\n    removeClass(overlay, c);\n  });\n  addClass(overlay, targetClass);\n}\n\n/**\n * Append the overlay to DOM.\n * @param {HTMLElement} container\n * @param {boolean} hasFade\n * @param {boolean=} isModal\n */\nfunction appendOverlay(container, hasFade, isModal) {\n  toggleOverlayType(isModal);\n  container.append(overlay);\n  if (hasFade) addClass(overlay, fadeClass);\n}\n\n/**\n * Shows the overlay to the user.\n */\nfunction showOverlay() {\n  if (!hasClass(overlay, showClass)) {\n    addClass(overlay, showClass);\n    reflow(overlay);\n  }\n}\n\n/**\n * Hides the overlay from the user.\n */\nfunction hideOverlay() {\n  removeClass(overlay, showClass);\n}\n\n/**\n * Removes the overlay from DOM.\n * @param {HTMLElement=} element\n */\nfunction removeOverlay(element) {\n  if (!getCurrentOpen(element)) {\n    removeClass(overlay, fadeClass);\n    overlay.remove();\n    resetScrollbar(element);\n  }\n}\n\n/**\n * @param {HTMLElement} element target\n * @returns {boolean}\n */\nfunction isVisible(element) {\n  return isHTMLElement(element)\n    && getElementStyle(element, 'visibility') !== 'hidden'\n    && element.offsetParent !== null;\n}\n\n/* Native JavaScript for Bootstrap 5 | Modal\n-------------------------------------------- */\n\n// MODAL PRIVATE GC\n// ================\nconst modalSelector = `.${modalString}`;\nconst modalToggleSelector = `[${dataBsToggle}=\"${modalString}\"]`;\nconst modalDismissSelector = `[${dataBsDismiss}=\"${modalString}\"]`;\nconst modalStaticClass = `${modalString}-static`;\n\nconst modalDefaults = {\n  backdrop: true, // boolean|string\n  keyboard: true, // boolean\n};\n\n/**\n * Static method which returns an existing `Modal` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Modal>}\n */\nconst getModalInstance = (element) => getInstance(element, modalComponent);\n\n/**\n * A `Modal` initialization callback.\n * @type {BSN.InitCallback<Modal>}\n */\nconst modalInitCallback = (element) => new Modal(element);\n\n// MODAL CUSTOM EVENTS\n// ===================\nconst showModalEvent = OriginalEvent(`show.bs.${modalString}`);\nconst shownModalEvent = OriginalEvent(`shown.bs.${modalString}`);\nconst hideModalEvent = OriginalEvent(`hide.bs.${modalString}`);\nconst hiddenModalEvent = OriginalEvent(`hidden.bs.${modalString}`);\n\n// MODAL PRIVATE METHODS\n// =====================\n/**\n * Applies special style for the `<body>` and fixed elements\n * when a modal instance is shown to the user.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction setModalScrollbar(self) {\n  const { element } = self;\n  const scrollbarWidth = measureScrollbar(element);\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  const { clientHeight: modalHeight, scrollHeight: modalScrollHeight } = element;\n  const modalOverflow = modalHeight !== modalScrollHeight;\n\n  /* istanbul ignore else */\n  if (!modalOverflow && scrollbarWidth) {\n    const pad = !isRTL(element) ? 'paddingRight' : /* istanbul ignore next */'paddingLeft';\n    const padStyle = {};\n    padStyle[pad] = `${scrollbarWidth}px`;\n    setElementStyle(element, padStyle);\n  }\n  setScrollbar(element, (modalOverflow || clientHeight !== scrollHeight));\n}\n\n/**\n * Toggles on/off the listeners of events that close the modal.\n *\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleModalDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n  action(element, mouseclickEvent, modalDismissHandler);\n  action(getWindow(element), resizeEvent, self.update, passiveHandler);\n  action(getDocument(element), keydownEvent, modalKeyHandler);\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Modal` instance.\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleModalHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, modalClickHandler));\n  }\n}\n\n/**\n * Executes after a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n * @param {Function} callback the `Modal` instance\n */\nfunction afterModalHide(self, callback) {\n  const { triggers, element, relatedTarget } = self;\n  removeOverlay(element);\n  setElementStyle(element, { paddingRight: '', display: '' });\n  toggleModalDismiss(self);\n\n  const focusElement = showModalEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (focusElement) focus(focusElement);\n\n  /* istanbul ignore else */\n  if (callback) callback();\n\n  hiddenModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, hiddenModalEvent);\n}\n\n/**\n * Executes after a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction afterModalShow(self) {\n  const { element, relatedTarget } = self;\n  focus(element);\n  toggleModalDismiss(self, true);\n\n  shownModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, shownModalEvent);\n}\n\n/**\n * Executes before a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction beforeModalShow(self) {\n  const { element, hasFade } = self;\n  setElementStyle(element, { display: 'block' });\n\n  setModalScrollbar(self);\n  /* istanbul ignore else */\n  if (!getCurrentOpen(element)) {\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, showClass);\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n\n  if (hasFade) emulateTransitionEnd(element, () => afterModalShow(self));\n  else afterModalShow(self);\n}\n\n/**\n * Executes before a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n * @param {Function=} callback when `true` skip animation\n */\nfunction beforeModalHide(self, callback) {\n  const {\n    element, options, hasFade,\n  } = self;\n\n  // callback can also be the transitionEvent object, we wanna make sure it's not\n  // call is not forced and overlay is visible\n  if (options.backdrop && !callback && hasFade && hasClass(overlay, showClass)\n    && !getCurrentOpen(element)) { // AND no modal is visible\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => afterModalHide(self));\n  } else {\n    afterModalHide(self, callback);\n  }\n}\n\n// MODAL EVENT HANDLERS\n// ====================\n/**\n * Handles the `click` event listener for modal.\n * @param {MouseEvent} e the `Event` object\n */\nfunction modalClickHandler(e) {\n  const { target } = e;\n\n  const trigger = target && closest(target, modalToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getModalInstance(element);\n\n  /* istanbul ignore else */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n  self.relatedTarget = trigger;\n  self.toggle();\n}\n\n/**\n * Handles the `keydown` event listener for modal\n * to hide the modal when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction modalKeyHandler({ code, target }) {\n  const element = querySelector(modalActiveSelector, getDocument(target));\n  const self = element && getModalInstance(element);\n\n  const { options } = self;\n  /* istanbul ignore else */\n  if (options.keyboard && code === keyEscape // the keyboard option is enabled and the key is 27\n    && hasClass(element, showClass)) { // the modal is not visible\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `click` event listeners that hide the modal.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction modalDismissHandler(e) {\n  const element = this;\n  const self = getModalInstance(element);\n\n  // this timer is needed\n  /* istanbul ignore next: must have a filter */\n  if (!self || Timer.get(element)) return;\n\n  const { options, isStatic, modalDialog } = self;\n  const { backdrop } = options;\n  const { target } = e;\n\n  const selectedText = getDocument(element).getSelection().toString().length;\n  const targetInsideDialog = modalDialog.contains(target);\n  const dismiss = target && closest(target, modalDismissSelector);\n\n  /* istanbul ignore else */\n  if (isStatic && !targetInsideDialog) {\n    Timer.set(element, () => {\n      addClass(element, modalStaticClass);\n      emulateTransitionEnd(modalDialog, () => staticTransitionEnd(self));\n    }, 17);\n  } else if (dismiss || (!selectedText && !isStatic && !targetInsideDialog && backdrop)) {\n    self.relatedTarget = dismiss || null;\n    self.hide();\n    e.preventDefault();\n  }\n}\n\n/**\n * Handles the `transitionend` event listeners for `Modal`.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction staticTransitionEnd(self) {\n  const { element, modalDialog } = self;\n  const duration = getElementTransitionDuration(modalDialog) + 17;\n  removeClass(element, modalStaticClass);\n  // user must wait for zoom out transition\n  Timer.set(element, () => Timer.clear(element), duration);\n}\n\n// MODAL DEFINITION\n// ================\n/** Returns a new `Modal` instance. */\nclass Modal extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually the `.modal` element\n   * @param {BSN.Options.Modal=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n\n    // the modal\n    const { element } = self;\n\n    // the modal-dialog\n    /** @type {(HTMLElement)} */\n    self.modalDialog = querySelector(`.${modalString}-dialog`, element);\n\n    // modal can have multiple triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(modalToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional internals\n    /** @type {boolean} */\n    self.isStatic = self.options.backdrop === 'static';\n    /** @type {boolean} */\n    self.hasFade = hasClass(element, fadeClass);\n    /** @type {HTMLElement?} */\n    self.relatedTarget = null;\n    /** @type {HTMLBodyElement | HTMLElement} */\n    self.container = getElementContainer(element);\n\n    // attach event listeners\n    toggleModalHandler(self, true);\n\n    // bind\n    self.update = self.update.bind(self);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return modalComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return modalDefaults; }\n  /* eslint-enable */\n\n  // MODAL PUBLIC METHODS\n  // ====================\n  /** Toggles the visibility of the modal. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the modal to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, hasFade, relatedTarget, container,\n    } = self;\n    const { backdrop } = options;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, showModalEvent);\n    if (showModalEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getModalInstance(currentOpen);\n      const that1 = this1\n        || /* istanbul ignore next */getInstance(currentOpen, 'Offcanvas');\n      that1.hide();\n    }\n\n    if (backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, hasFade, true);\n      } else {\n        toggleOverlayType(true);\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n\n      showOverlay();\n      setTimeout(() => beforeModalShow(self), overlayDelay);\n    } else {\n      beforeModalShow(self);\n      /* istanbul ignore else */\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hide the modal from the user.\n   * @param {Function=} callback when defined it will skip animation\n   */\n  hide(callback) {\n    const self = this;\n    const {\n      element, hasFade, relatedTarget,\n    } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, hideModalEvent);\n    if (hideModalEvent.defaultPrevented) return;\n    removeClass(element, showClass);\n    setAttribute(element, ariaHidden, 'true');\n    removeAttribute(element, ariaModal);\n\n    // if (hasFade && callback) {\n    /* istanbul ignore else */\n    if (hasFade) {\n      emulateTransitionEnd(element, () => beforeModalHide(self, callback));\n    } else {\n      beforeModalHide(self, callback);\n    }\n  }\n\n  /**\n   * Updates the modal layout.\n   * @this {Modal} the modal instance\n   */\n  update() {\n    const self = this;\n    /* istanbul ignore else */\n    if (hasClass(self.element, showClass)) setModalScrollbar(self);\n  }\n\n  /** Removes the `Modal` component from target element. */\n  dispose() {\n    const self = this;\n    toggleModalHandler(self);\n    // use callback\n    self.hide(() => super.dispose());\n  }\n}\n\nObjectAssign(Modal, {\n  selector: modalSelector,\n  init: modalInitCallback,\n  getInstance: getModalInstance,\n});\n\n/** @type {string} */\nconst offcanvasComponent = 'Offcanvas';\n\n/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Offcanvas>}\n */\nconst getOffcanvasInstance = (element) => getInstance(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n * @type {BSN.InitCallback<Offcanvas>}\n */\nconst offcanvasInitCallback = (element) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = OriginalEvent(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = OriginalEvent(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = OriginalEvent(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = OriginalEvent(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction setOffCanvasScrollbar(self) {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n}\n\n/**\n * Toggles on/off the `click` event listeners.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true*, listeners are added\n */\nfunction toggleOffcanvasEvents(self, add) {\n  const action = add ? addListener : removeListener;\n  self.triggers.forEach((btn) => action(btn, mouseclickEvent, offcanvasTriggerHandler));\n}\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true* listeners are added\n */\nfunction toggleOffCanvasDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n}\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction beforeOffcanvasShow(self) {\n  const { element, options } = self;\n\n  /* istanbul ignore else */\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n}\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {Function=} callback the hide callback\n */\nfunction beforeOffcanvasHide(self, callback) {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => hideOffcanvasComplete(self, callback));\n  } else hideOffcanvasComplete(self, callback);\n}\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasTriggerHandler(e) {\n  const trigger = closest(this, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n}\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasDismissHandler(e) {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element);\n  const self = getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must have a filter */\n  if (!self) return;\n\n  const { options, triggers } = self;\n  const { backdrop } = options;\n  const trigger = closest(target, offcanvasToggleSelector);\n  const selection = getDocument(element).getSelection();\n\n  if (overlay.contains(target) && backdrop === 'static') return;\n\n  /* istanbul ignore else */\n  if (!(selection && selection.toString().length)\n    && ((!element.contains(target) && backdrop\n    && /* istanbul ignore next */(!trigger || triggers.includes(target)))\n    || (offCanvasDismiss && offCanvasDismiss.contains(target)))) {\n    self.relatedTarget = offCanvasDismiss && offCanvasDismiss.contains(target)\n      ? offCanvasDismiss : null;\n    self.hide();\n  }\n\n  /* istanbul ignore next */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction offcanvasKeyDismissHandler({ code, target }) {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target));\n\n  const self = getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must filter */\n  if (!self) return;\n\n  /* istanbul ignore else */\n  if (self.options.keyboard && code === keyEscape) {\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction showOffcanvasComplete(self) {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n}\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {Function} callback the hide callback\n */\nfunction hideOffcanvasComplete(self, callback) {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find((x) => isVisible(x));\n  /* istanbul ignore else */\n  if (visibleTrigger) focus(visibleTrigger);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n  // callback\n  if (callback) callback();\n}\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nclass Offcanvas extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually an `.offcanvas` element\n   * @param {BSN.Options.Offcanvas=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    const self = this;\n\n    // instance element\n    const { element } = self;\n\n    // all the triggering buttons\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional instance property\n    /** @type {HTMLBodyElement | HTMLElement} */\n    self.container = getElementContainer(element);\n    /** @type {HTMLElement?} */\n    self.relatedTarget = null;\n\n    // attach event listeners\n    toggleOffcanvasEvents(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return offcanvasComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return offcanvasDefaults; }\n  /* eslint-enable */\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, container, relatedTarget,\n    } = self;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showOffcanvasEvent.relatedTarget = relatedTarget;\n    shownOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, showOffcanvasEvent);\n    if (showOffcanvasEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getOffcanvasInstance(currentOpen);\n      const that1 = this1\n        || /* istanbul ignore next */getInstance(currentOpen, 'Modal');\n      that1.hide();\n    }\n\n    if (options.backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, true);\n      } else {\n        toggleOverlayType();\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n      showOverlay();\n\n      setTimeout(() => beforeOffcanvasShow(self), overlayDelay);\n    } else {\n      beforeOffcanvasShow(self);\n      /* istanbul ignore else */\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hides the offcanvas from the user.\n   * @param {Function=} callback when `true` it will skip animation\n   */\n  hide(callback) {\n    const self = this;\n    const { element, relatedTarget } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideOffcanvasEvent.relatedTarget = relatedTarget;\n    hiddenOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, hideOffcanvasEvent);\n    if (hideOffcanvasEvent.defaultPrevented) return;\n\n    addClass(element, offcanvasTogglingClass);\n    removeClass(element, showClass);\n\n    if (!callback) {\n      emulateTransitionEnd(element, () => beforeOffcanvasHide(self, callback));\n    } else beforeOffcanvasHide(self, callback);\n  }\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const self = this;\n    toggleOffcanvasEvents(self);\n    self.hide(() => super.dispose());\n  }\n}\n\nObjectAssign(Offcanvas, {\n  selector: offcanvasSelector,\n  init: offcanvasInitCallback,\n  getInstance: getOffcanvasInstance,\n});\n\n/** @type {string} */\nconst popoverString = 'popover';\n\n/** @type {string} */\nconst popoverComponent = 'Popover';\n\n/** @type {string} */\nconst tooltipString = 'tooltip';\n\n/**\n * Returns a template for Popover / Tooltip.\n *\n * @param {string} tipType the expected markup type\n * @returns {string} the template markup\n */\nfunction getTipTemplate(tipType) {\n  const isTooltip = tipType === tooltipString;\n  const bodyClass = isTooltip ? `${tipType}-inner` : `${tipType}-body`;\n  const header = !isTooltip ? `<h3 class=\"${tipType}-header\"></h3>` : '';\n  const arrow = `<div class=\"${tipType}-arrow\"></div>`;\n  const body = `<div class=\"${bodyClass}\"></div>`;\n  return `<div class=\"${tipType}\" role=\"${tooltipString}\">${header + arrow + body}</div>`;\n}\n\n/**\n * Checks if an element is an `<svg>` (or any type of SVG element),\n * `<img>` or `<video>`.\n *\n * *Tooltip* / *Popover* works different with media elements.\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\n\nconst isMedia = (element) => (\n  element\n  && element.nodeType === 1\n  && ['SVG', 'Image', 'Video'].some((s) => element.constructor.name.includes(s))) || false;\n\n/**\n * Returns an `{x,y}` object with the target\n * `HTMLElement` / `Node` scroll position.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement | Window} element target node / element\n * @returns {{x: number, y: number}} the scroll tuple\n */\nfunction getNodeScroll(element) {\n  const isWin = 'scrollX' in element;\n  const x = isWin ? element.scrollX : element.scrollLeft;\n  const y = isWin ? element.scrollY : element.scrollTop;\n\n  return { x, y };\n}\n\n/**\n * Checks if a target `HTMLElement` is affected by scale.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element target\n * @returns {boolean} the query result\n */\nfunction isScaledElement(element) {\n  if (!element || !isHTMLElement(element)) return false;\n  const { width, height } = getBoundingClientRect(element);\n  const { offsetWidth, offsetHeight } = element;\n  return Math.round(width) !== offsetWidth\n    || Math.round(height) !== offsetHeight;\n}\n\n/**\n * Returns the rect relative to an offset parent.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element target\n * @param {ParentNode | Window} offsetParent the container / offset parent\n * @param {{x: number, y: number}} scroll the offsetParent scroll position\n * @returns {SHORTY.OffsetRect}\n */\nfunction getRectRelativeToOffsetParent(element, offsetParent, scroll) {\n  const isParentAnElement = isHTMLElement(offsetParent);\n  const rect = getBoundingClientRect(element, isParentAnElement && isScaledElement(offsetParent));\n  const offsets = { x: 0, y: 0 };\n\n  /* istanbul ignore next */\n  if (isParentAnElement) {\n    const offsetRect = getBoundingClientRect(offsetParent, true);\n    offsets.x = offsetRect.x + offsetParent.clientLeft;\n    offsets.y = offsetRect.y + offsetParent.clientTop;\n  }\n\n  return {\n    x: rect.left + scroll.x - offsets.x,\n    y: rect.top + scroll.y - offsets.y,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\n/** @type {Record<string, string>} */\nconst tipClassPositions = {\n  top: 'top',\n  bottom: 'bottom',\n  left: 'start',\n  right: 'end',\n};\n\n/**\n * Style popovers and tooltips.\n * @param {BSN.Tooltip | BSN.Popover} self the `Popover` / `Tooltip` instance\n * @param {PointerEvent=} e event object\n */\nfunction styleTip(self, e) {\n  const tipClasses = /\\b(top|bottom|start|end)+/;\n  const {\n    element, tooltip, options, arrow, offsetParent,\n  } = self;\n  const tipPositions = { ...tipClassPositions };\n\n  const RTL = isRTL(element);\n  if (RTL) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // reset tooltip style (top: 0, left: 0 works best)\n  setElementStyle(tooltip, {\n    // top: '0px', left: '0px', right: '', bottom: '',\n    top: '', left: '', right: '', bottom: '',\n  });\n  const isPopover = self.name === popoverComponent;\n  const {\n    offsetWidth: tipWidth, offsetHeight: tipHeight,\n  } = tooltip;\n  const {\n    clientWidth: htmlcw, clientHeight: htmlch,\n  } = getDocumentElement(element);\n  const { container } = options;\n  let { placement } = options;\n  const {\n    left: parentLeft, right: parentRight, top: parentTop,\n  } = getBoundingClientRect(container, true);\n  const {\n    clientWidth: parentCWidth, offsetWidth: parentOWidth,\n  } = container;\n  const scrollbarWidth = Math.abs(parentCWidth - parentOWidth);\n  // const tipAbsolute = getElementStyle(tooltip, 'position') === 'absolute';\n  const parentPosition = getElementStyle(container, 'position');\n  // const absoluteParent = parentPosition === 'absolute';\n  const fixedParent = parentPosition === 'fixed';\n  const staticParent = parentPosition === 'static';\n  const stickyParent = parentPosition === 'sticky';\n  const isSticky = stickyParent && parentTop === parseFloat(getElementStyle(container, 'top'));\n  // const absoluteTarget = getElementStyle(element, 'position') === 'absolute';\n  // const stickyFixedParent = ['sticky', 'fixed'].includes(parentPosition);\n  const leftBoundry = RTL && fixedParent ? scrollbarWidth : 0;\n  const rightBoundry = fixedParent ? parentCWidth + parentLeft + (RTL ? scrollbarWidth : 0)\n    : parentCWidth + parentLeft + (htmlcw - parentRight) - 1;\n  const {\n    width: elemWidth,\n    height: elemHeight,\n    left: elemRectLeft,\n    right: elemRectRight,\n    top: elemRectTop,\n  } = getBoundingClientRect(element, true);\n\n  const scroll = getNodeScroll(offsetParent);\n  const { x, y } = getRectRelativeToOffsetParent(element, offsetParent, scroll);\n  // reset arrow style\n  setElementStyle(arrow, {\n    top: '', left: '', right: '', bottom: '',\n  });\n  let topPosition;\n  let leftPosition;\n  let rightPosition;\n  let arrowTop;\n  let arrowLeft;\n  let arrowRight;\n\n  const arrowWidth = arrow.offsetWidth || 0;\n  const arrowHeight = arrow.offsetHeight || 0;\n  const arrowAdjust = arrowWidth / 2;\n\n  // check placement\n  let topExceed = elemRectTop - tipHeight - arrowHeight < 0;\n  let bottomExceed = elemRectTop + tipHeight + elemHeight\n    + arrowHeight >= htmlch;\n  let leftExceed = elemRectLeft - tipWidth - arrowWidth < leftBoundry;\n  let rightExceed = elemRectLeft + tipWidth + elemWidth\n    + arrowWidth >= rightBoundry;\n\n  const horizontal = ['left', 'right'];\n  const vertical = ['top', 'bottom'];\n\n  topExceed = horizontal.includes(placement)\n    ? elemRectTop + elemHeight / 2 - tipHeight / 2 - arrowHeight < 0\n    : topExceed;\n  bottomExceed = horizontal.includes(placement)\n    ? elemRectTop + tipHeight / 2 + elemHeight / 2 + arrowHeight >= htmlch\n    : bottomExceed;\n  leftExceed = vertical.includes(placement)\n    ? elemRectLeft + elemWidth / 2 - tipWidth / 2 < leftBoundry\n    : leftExceed;\n  rightExceed = vertical.includes(placement)\n    ? elemRectLeft + tipWidth / 2 + elemWidth / 2 >= rightBoundry\n    : rightExceed;\n\n  // first remove side positions if both left and right limits are exceeded\n  // we usually fall back to top|bottom\n  placement = (horizontal.includes(placement)) && leftExceed && rightExceed ? 'top' : placement;\n  // second, recompute placement\n  placement = placement === 'top' && topExceed ? 'bottom' : placement;\n  placement = placement === 'bottom' && bottomExceed ? 'top' : placement;\n  placement = placement === 'left' && leftExceed ? 'right' : placement;\n  placement = placement === 'right' && rightExceed ? 'left' : placement;\n\n  // update tooltip/popover class\n  if (!tooltip.className.includes(placement)) {\n    tooltip.className = tooltip.className.replace(tipClasses, tipPositions[placement]);\n  }\n\n  // compute tooltip / popover coordinates\n  /* istanbul ignore else */\n  if (horizontal.includes(placement)) { // secondary|side positions\n    if (placement === 'left') { // LEFT\n      leftPosition = x - tipWidth - (isPopover ? arrowWidth : 0);\n    } else { // RIGHT\n      leftPosition = x + elemWidth + (isPopover ? arrowWidth : 0);\n    }\n\n    // adjust top and arrow\n    if (topExceed) {\n      topPosition = y;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = elemHeight / 2 - arrowWidth;\n    } else if (bottomExceed) {\n      topPosition = y - tipHeight + elemHeight;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight - elemHeight / 2 - arrowWidth;\n    } else {\n      topPosition = y - tipHeight / 2 + elemHeight / 2;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight / 2 - arrowHeight / 2;\n    }\n  } else if (vertical.includes(placement)) {\n    if (e && isMedia(element)) {\n      let eX = 0;\n      let eY = 0;\n      if (staticParent) {\n        eX = e.pageX;\n        eY = e.pageY;\n      } else { // fixedParent | stickyParent\n        eX = e.clientX - parentLeft + (fixedParent ? scroll.x : 0);\n        eY = e.clientY - parentTop + (fixedParent ? scroll.y : 0);\n      }\n\n      // some weird RTL bug\n      eX -= RTL && fixedParent && scrollbarWidth ? scrollbarWidth : 0;\n\n      if (placement === 'top') {\n        topPosition = eY - tipHeight - arrowWidth;\n      } else {\n        topPosition = eY + arrowWidth;\n      }\n\n      // adjust (left | right) and also the arrow\n      if (e.clientX - tipWidth / 2 < leftBoundry) {\n        leftPosition = 0;\n        arrowLeft = eX - arrowAdjust;\n      } else if (e.clientX + tipWidth / 2 > rightBoundry) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = rightBoundry - eX - arrowAdjust;\n        arrowRight -= fixedParent ? parentLeft + (RTL ? scrollbarWidth : 0) : 0;\n\n      // normal top/bottom\n      } else {\n        leftPosition = eX - tipWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    } else {\n      if (placement === 'top') {\n        topPosition = y - tipHeight - (isPopover ? arrowHeight : 0);\n      } else { // BOTTOM\n        topPosition = y + elemHeight + (isPopover ? arrowHeight : 0);\n      }\n\n      // adjust left | right and also the arrow\n      if (leftExceed) {\n        leftPosition = 0;\n        arrowLeft = x + elemWidth / 2 - arrowAdjust;\n      } else if (rightExceed) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = elemWidth / 2 + rightBoundry - elemRectRight - arrowAdjust;\n      } else {\n        leftPosition = x - tipWidth / 2 + elemWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    }\n  }\n\n  // apply style to tooltip/popover\n  setElementStyle(tooltip, {\n    top: `${topPosition}px`,\n    left: leftPosition === 'auto' ? leftPosition : `${leftPosition}px`,\n    right: rightPosition !== undefined ? `${rightPosition}px` : '',\n  });\n\n  // update arrow placement\n  /* istanbul ignore else */\n  if (isHTMLElement(arrow)) {\n    if (arrowTop !== undefined) {\n      arrow.style.top = `${arrowTop}px`;\n    }\n    if (arrowLeft !== undefined) {\n      arrow.style.left = `${arrowLeft}px`;\n    } else if (arrowRight !== undefined) {\n      arrow.style.right = `${arrowRight}px`;\n    }\n  }\n}\n\nconst tooltipDefaults = {\n  /** @type {string} */\n  template: getTipTemplate(tooltipString),\n  /** @type {string?} */\n  title: null, // string\n  /** @type {string?} */\n  customClass: null, // string | null\n  /** @type {string} */\n  trigger: 'hover focus',\n  /** @type {string?} */\n  placement: 'top', // string\n  /** @type {((c:string)=>string)?} */\n  sanitizeFn: null, // function\n  /** @type {boolean} */\n  animation: true, // bool\n  /** @type {number} */\n  delay: 200, // number\n  /** @type {HTMLElement?} */\n  container: null,\n};\n\n/**\n * A global namespace for aria-describedby.\n * @type {string}\n */\nconst ariaDescribedBy = 'aria-describedby';\n\n/**\n * A global namespace for `mousedown` event.\n * @type {string}\n */\nconst mousedownEvent = 'mousedown';\n\n/**\n * A global namespace for `mousemove` event.\n * @type {string}\n */\nconst mousemoveEvent = 'mousemove';\n\n/**\n * A global namespace for `focusin` event.\n * @type {string}\n */\nconst focusinEvent = 'focusin';\n\n/**\n * A global namespace for `focusout` event.\n * @type {string}\n */\nconst focusoutEvent = 'focusout';\n\n/**\n * A global namespace for `hover` event.\n * @type {string}\n */\nconst mousehoverEvent = 'hover';\n\n/**\n * A global namespace for `touchstart` event.\n * @type {string}\n */\nconst touchstartEvent = 'touchstart';\n\nlet elementUID = 0;\nlet elementMapUID = 0;\nconst elementIDMap = new Map();\n\n/**\n * Returns a unique identifier for popover, tooltip, scrollspy.\n *\n * @param {HTMLElement} element target element\n * @param {string=} key predefined key\n * @returns {number} an existing or new unique ID\n */\nfunction getUID(element, key) {\n  let result = key ? elementUID : elementMapUID;\n\n  if (key) {\n    const elID = getUID(element);\n    const elMap = elementIDMap.get(elID) || new Map();\n    if (!elementIDMap.has(elID)) {\n      elementIDMap.set(elID, elMap);\n    }\n    if (!elMap.has(key)) {\n      elMap.set(key, result);\n      elementUID += 1;\n    } else result = elMap.get(key);\n  } else {\n    const elkey = element.id || element;\n\n    if (!elementIDMap.has(elkey)) {\n      elementIDMap.set(elkey, result);\n      elementMapUID += 1;\n    } else result = elementIDMap.get(elkey);\n  }\n  return result;\n}\n\n/**\n * Checks if an object is a `Function`.\n *\n * @param {any} fn the target object\n * @returns {boolean} the query result\n */\nconst isFunction = (fn) => (fn && fn.constructor.name === 'Function') || false;\n\nconst { userAgentData: uaDATA } = navigator;\n\n/**\n * A global namespace for `userAgentData` object.\n */\nconst userAgentData = uaDATA;\n\nconst { userAgent: userAgentString } = navigator;\n\n/**\n * A global namespace for `navigator.userAgent` string.\n */\nconst userAgent = userAgentString;\n\nconst appleBrands = /(iPhone|iPod|iPad)/;\n\n/**\n * A global `boolean` for Apple browsers.\n * @type {boolean}\n */\nconst isApple = userAgentData ? userAgentData.brands.some((x) => appleBrands.test(x.brand))\n  : /* istanbul ignore next */appleBrands.test(userAgent);\n\n/**\n * Global namespace for `data-bs-title` attribute.\n */\nconst dataOriginalTitle = 'data-original-title';\n\n/** @type {string} */\nconst tooltipComponent = 'Tooltip';\n\n/**\n * Checks if an object is a `NodeList`.\n * => equivalent to `object instanceof NodeList`\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isNodeList = (object) => (object && object.constructor.name === 'NodeList') || false;\n\n/**\n * Shortcut for `typeof SOMETHING === \"string\"`.\n *\n * @param  {any} str input value\n * @returns {boolean} the query result\n */\nconst isString = (str) => typeof str === 'string';\n\n/**\n * Shortcut for `Array.isArray()` static method.\n *\n * @param  {any} arr array-like iterable object\n * @returns {boolean} the query result\n */\nconst isArray = (arr) => Array.isArray(arr);\n\n/**\n * Append an existing `Element` to Popover / Tooltip component or HTML\n * markup string to be parsed & sanitized to be used as popover / tooltip content.\n *\n * @param {HTMLElement} element target\n * @param {Node | string} content the `Element` to append / string\n * @param {ReturnType<any>} sanitizeFn a function to sanitize string content\n */\nfunction setHtml(element, content, sanitizeFn) {\n  /* istanbul ignore next */\n  if (!isHTMLElement(element) || (isString(content) && !content.length)) return;\n\n  /* istanbul ignore else */\n  if (isString(content)) {\n    let dirty = content.trim(); // fixing #233\n    if (isFunction(sanitizeFn)) dirty = sanitizeFn(dirty);\n\n    const win = getWindow(element);\n    const domParser = new win.DOMParser();\n    const tempDocument = domParser.parseFromString(dirty, 'text/html');\n    element.append(...[...tempDocument.body.childNodes]);\n  } else if (isHTMLElement(content)) {\n    element.append(content);\n  } else if (isNodeList(content)\n    || (isArray(content) && content.every(isNode))) {\n    element.append(...[...content]);\n  }\n}\n\n/**\n * Creates a new tooltip / popover.\n *\n * @param {BSN.Popover | BSN.Tooltip} self the `Tooltip` / `Popover` instance\n */\nfunction createTip(self) {\n  const { id, element, options } = self;\n  const {\n    animation, customClass, sanitizeFn, placement, dismissible,\n    title, content, template, btnClose,\n  } = options;\n  const isTooltip = self.name === tooltipComponent;\n  const tipString = isTooltip ? tooltipString : popoverString;\n  const tipPositions = { ...tipClassPositions };\n  let titleParts = [];\n  let contentParts = [];\n\n  if (isRTL(element)) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // set initial popover class\n  const placementClass = `bs-${tipString}-${tipPositions[placement]}`;\n\n  // load template\n  /** @type {HTMLElement?} */\n  let tooltipTemplate;\n  if (isHTMLElement(template)) {\n    tooltipTemplate = template;\n  } else {\n    const htmlMarkup = createElement('div');\n    setHtml(htmlMarkup, template, sanitizeFn);\n    tooltipTemplate = htmlMarkup.firstChild;\n  }\n\n  // set popover markup\n  self.tooltip = isHTMLElement(tooltipTemplate) && tooltipTemplate.cloneNode(true);\n\n  const { tooltip } = self;\n\n  // set id and role attributes\n  setAttribute(tooltip, 'id', id);\n  setAttribute(tooltip, 'role', tooltipString);\n\n  const bodyClass = isTooltip ? `${tooltipString}-inner` : `${popoverString}-body`;\n  const tooltipHeader = isTooltip ? null : querySelector(`.${popoverString}-header`, tooltip);\n  const tooltipBody = querySelector(`.${bodyClass}`, tooltip);\n\n  // set arrow and enable access for styleTip\n  self.arrow = querySelector(`.${tipString}-arrow`, tooltip);\n  const { arrow } = self;\n\n  if (isHTMLElement(title)) titleParts = [title.cloneNode(true)];\n  else {\n    const tempTitle = createElement('div');\n    setHtml(tempTitle, title, sanitizeFn);\n    titleParts = [...[...tempTitle.childNodes]];\n  }\n\n  if (isHTMLElement(content)) contentParts = [content.cloneNode(true)];\n  else {\n    const tempContent = createElement('div');\n    setHtml(tempContent, content, sanitizeFn);\n    contentParts = [...[...tempContent.childNodes]];\n  }\n\n  // set dismissible button\n  if (dismissible) {\n    if (title) {\n      if (isHTMLElement(btnClose)) titleParts = [...titleParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div');\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        titleParts = [...titleParts, tempBtn.firstChild];\n      }\n    } else {\n      /* istanbul ignore else */\n      if (tooltipHeader) tooltipHeader.remove();\n      if (isHTMLElement(btnClose)) contentParts = [...contentParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div');\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        contentParts = [...contentParts, tempBtn.firstChild];\n      }\n    }\n  }\n\n  // fill the template with content from options / data attributes\n  // also sanitize title && content\n  /* istanbul ignore else */\n  if (!isTooltip) {\n    /* istanbul ignore else */\n    if (title && tooltipHeader) setHtml(tooltipHeader, titleParts, sanitizeFn);\n    /* istanbul ignore else */\n    if (content && tooltipBody) setHtml(tooltipBody, contentParts, sanitizeFn);\n    // set btn\n    self.btn = querySelector('.btn-close', tooltip);\n  } else if (title && tooltipBody) setHtml(tooltipBody, title, sanitizeFn);\n\n  // Bootstrap 5.2.x\n  addClass(tooltip, 'position-absolute');\n  addClass(arrow, 'position-absolute');\n\n  // set popover animation and placement\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, tipString)) addClass(tooltip, tipString);\n  /* istanbul ignore else */\n  if (animation && !hasClass(tooltip, fadeClass)) addClass(tooltip, fadeClass);\n  /* istanbul ignore else */\n  if (customClass && !hasClass(tooltip, customClass)) {\n    addClass(tooltip, customClass);\n  }\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);\n}\n\n/**\n * @param {HTMLElement} tip target\n * @param {ParentNode} container parent container\n * @returns {boolean}\n */\nfunction isVisibleTip(tip, container) {\n  return isHTMLElement(tip) && container.contains(tip);\n}\n\n/* Native JavaScript for Bootstrap 5 | Tooltip\n---------------------------------------------- */\n\n// TOOLTIP PRIVATE GC\n// ==================\nconst tooltipSelector = `[${dataBsToggle}=\"${tooltipString}\"],[data-tip=\"${tooltipString}\"]`;\nconst titleAttr = 'title';\n\n/**\n * Static method which returns an existing `Tooltip` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tooltip>}\n */\nlet getTooltipInstance = (element) => getInstance(element, tooltipComponent);\n\n/**\n * A `Tooltip` initialization callback.\n * @type {BSN.InitCallback<Tooltip>}\n */\nconst tooltipInitCallback = (element) => new Tooltip(element);\n\n// TOOLTIP PRIVATE METHODS\n// =======================\n/**\n * Removes the tooltip from the DOM.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction removeTooltip(self) {\n  const { element, tooltip } = self;\n  removeAttribute(element, ariaDescribedBy);\n  tooltip.remove();\n}\n\n/**\n * Executes after the instance has been disposed.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {Function=} callback the parent dispose callback\n */\nfunction disposeTooltipComplete(self, callback) {\n  const { element } = self;\n  toggleTooltipHandlers(self);\n\n  /* istanbul ignore else */\n  if (hasAttribute(element, dataOriginalTitle) && self.name === tooltipComponent) {\n    toggleTooltipTitle(self);\n  }\n  /* istanbul ignore else */\n  if (callback) callback();\n}\n\n/**\n * Toggles on/off the special `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipAction(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n\n  action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      action(getWindow(element), ev, self.update, passiveHandler);\n    });\n  }\n}\n\n/**\n * Executes after the tooltip was shown to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction tooltipShownAction(self) {\n  const { element } = self;\n  const shownTooltipEvent = OriginalEvent(`shown.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self, true);\n  dispatchEvent(element, shownTooltipEvent);\n  Timer.clear(element, 'in');\n}\n\n/**\n * Executes after the tooltip was hidden to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {Function=} callback the dispose callback\n */\nfunction tooltipHiddenAction(self, callback) {\n  const { element } = self;\n  const hiddenTooltipEvent = OriginalEvent(`hidden.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self);\n  removeTooltip(self);\n  dispatchEvent(element, hiddenTooltipEvent);\n  if (isFunction(callback)) callback();\n  Timer.clear(element, 'out');\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  // btn is only for dismissible popover\n  const { element, options, btn } = self;\n  const { trigger, dismissible } = options;\n\n  if (trigger.includes('manual')) return;\n\n  self.enabled = !!add;\n\n  /** @type {string[]} */\n  const triggerOptions = trigger.split(' ');\n  const elemIsMedia = isMedia(element);\n\n  if (elemIsMedia) {\n    action(element, mousemoveEvent, self.update, passiveHandler);\n  }\n\n  triggerOptions.forEach((tr) => {\n    /* istanbul ignore else */\n    if (elemIsMedia || tr === mousehoverEvent) {\n      action(element, mousedownEvent, self.show);\n      action(element, mouseenterEvent, self.show);\n\n      /* istanbul ignore else */\n      if (dismissible && btn) {\n        action(btn, mouseclickEvent, self.hide);\n      } else {\n        action(element, mouseleaveEvent, self.hide);\n        action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n      }\n    } else if (tr === mouseclickEvent) {\n      action(element, tr, (!dismissible ? self.toggle : self.show));\n    } else if (tr === focusEvent) {\n      action(element, focusinEvent, self.show);\n      /* istanbul ignore else */\n      if (!dismissible) action(element, focusoutEvent, self.hide);\n      /* istanbul ignore else */\n      if (isApple) {\n        action(element, mouseclickEvent, () => focus(element));\n      }\n    }\n  });\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners that hide/update the tooltip.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipOpenHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element, options, offsetParent } = self;\n  const { container } = options;\n  const { offsetHeight, scrollHeight } = container;\n  const parentModal = closest(element, `.${modalString}`);\n  const parentOffcanvas = closest(element, `.${offcanvasString}`);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    const win = getWindow(element);\n    const overflow = offsetHeight !== scrollHeight;\n    const scrollTarget = overflow || offsetParent !== win ? container : win;\n    action(win, resizeEvent, self.update, passiveHandler);\n    action(scrollTarget, scrollEvent, self.update, passiveHandler);\n  }\n\n  // dismiss tooltips inside modal / offcanvas\n  if (parentModal) action(parentModal, `hide.bs.${modalString}`, self.hide);\n  if (parentOffcanvas) action(parentOffcanvas, `hide.bs.${offcanvasString}`, self.hide);\n}\n\n/**\n * Toggles the `title` and `data-original-title` attributes.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {string=} content when `true`, event listeners are added\n */\nfunction toggleTooltipTitle(self, content) {\n  // [0 - add, 1 - remove] | [0 - remove, 1 - add]\n  const titleAtt = [dataOriginalTitle, titleAttr];\n  const { element } = self;\n\n  setAttribute(element, titleAtt[content ? 0 : 1],\n    (content || getAttribute(element, titleAtt[0])));\n  removeAttribute(element, titleAtt[content ? 1 : 0]);\n}\n\n// TOOLTIP DEFINITION\n// ==================\n/** Creates a new `Tooltip` instance. */\nclass Tooltip extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.Tooltip=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n    const { element } = self;\n    const isTooltip = self.name === tooltipComponent;\n    const tipString = isTooltip ? tooltipString : popoverString;\n    const tipComponent = isTooltip ? tooltipComponent : popoverComponent;\n\n    /* istanbul ignore next: this is to set Popover too */\n    getTooltipInstance = (elem) => getInstance(elem, tipComponent);\n\n    // additional properties\n    /** @type {any} */\n    self.tooltip = {};\n    if (!isTooltip) {\n      /** @type {any?} */\n      self.btn = null;\n    }\n    /** @type {any} */\n    self.arrow = {};\n    /** @type {any} */\n    self.offsetParent = {};\n    /** @type {boolean} */\n    self.enabled = true;\n    /** @type {string} Set unique ID for `aria-describedby`. */\n    self.id = `${tipString}-${getUID(element, tipString)}`;\n\n    // instance options\n    const { options } = self;\n\n    // invalidate\n    if ((!options.title && isTooltip) || (!isTooltip && !options.content)) {\n      // throw Error(`${this.name} Error: target has no content set.`);\n      return;\n    }\n\n    const container = querySelector(options.container, getDocument(element));\n    const idealContainer = getElementContainer(element);\n\n    // bypass container option when its position is static/relative\n    self.options.container = !container || (container\n      && ['static', 'relative'].includes(getElementStyle(container, 'position')))\n      ? idealContainer\n      : /* istanbul ignore next */container || getDocumentBody(element);\n\n    // reset default options\n    tooltipDefaults[titleAttr] = null;\n\n    // all functions bind\n    self.handleTouch = self.handleTouch.bind(self);\n    self.update = self.update.bind(self);\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n    self.toggle = self.toggle.bind(self);\n\n    // set title attributes and add event listeners\n    /* istanbul ignore else */\n    if (hasAttribute(element, titleAttr) && isTooltip) {\n      toggleTooltipTitle(self, options.title);\n    }\n\n    // create tooltip here\n    createTip(self);\n\n    // attach events\n    toggleTooltipHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return tooltipComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return tooltipDefaults; }\n  /* eslint-enable */\n\n  // TOOLTIP PUBLIC METHODS\n  // ======================\n  /**\n   * Shows the tooltip.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip}\n   */\n  show(e) {\n    const self = this;\n    const {\n      options, tooltip, element, id,\n    } = self;\n    const { container, animation } = options;\n    const outTimer = Timer.get(element, 'out');\n\n    Timer.clear(element, 'out');\n\n    if (tooltip && !outTimer && !isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const showTooltipEvent = OriginalEvent(`show.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, showTooltipEvent);\n        if (showTooltipEvent.defaultPrevented) return;\n\n        // append to container\n        container.append(tooltip);\n        setAttribute(element, ariaDescribedBy, `#${id}`);\n        // set offsetParent\n        self.offsetParent = getElementContainer(tooltip, true);\n\n        self.update(e);\n        toggleTooltipOpenHandlers(self, true);\n\n        /* istanbul ignore else */\n        if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);\n        /* istanbul ignore else */\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipShownAction(self));\n        else tooltipShownAction(self);\n      }, 17, 'in');\n    }\n  }\n\n  /**\n   * Hides the tooltip.\n   *\n   * @this {Tooltip} the Tooltip instance\n   * @param {Function=} callback the dispose callback\n   */\n  hide(callback) {\n    const self = this;\n    const { options, tooltip, element } = self;\n    const { container, animation, delay } = options;\n\n    Timer.clear(element, 'in');\n\n    /* istanbul ignore else */\n    if (tooltip && isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const hideTooltipEvent = OriginalEvent(`hide.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, hideTooltipEvent);\n\n        if (hideTooltipEvent.defaultPrevented) return;\n\n        removeClass(tooltip, showClass);\n        toggleTooltipOpenHandlers(self);\n\n        /* istanbul ignore else */\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipHiddenAction(self, callback));\n        else tooltipHiddenAction(self, callback);\n      }, delay + 17, 'out');\n    }\n  }\n\n  /**\n   * Updates the tooltip position.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the `Tooltip` instance\n   */\n  update(e) {\n    styleTip(this, e);\n  }\n\n  /**\n   * Toggles the tooltip visibility.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the instance\n   */\n  toggle(e) {\n    const self = this;\n    const { tooltip, options } = self;\n\n    if (!isVisibleTip(tooltip, options.container)) self.show(e);\n    else self.hide();\n  }\n\n  /** Enables the tooltip. */\n  enable() {\n    const self = this;\n    const { enabled } = self;\n    /* istanbul ignore else */\n    if (!enabled) {\n      toggleTooltipHandlers(self, true);\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Disables the tooltip. */\n  disable() {\n    const self = this;\n    const {\n      tooltip, options, enabled,\n    } = self;\n    const { animation, container } = options;\n    /* istanbul ignore else */\n    if (enabled) {\n      if (isVisibleTip(tooltip, container) && animation) {\n        self.hide(() => toggleTooltipHandlers(self));\n      } else {\n        toggleTooltipHandlers(self);\n      }\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    const self = this;\n    if (!self.enabled) self.enable();\n    else self.disable();\n  }\n\n  /**\n   * Handles the `touchstart` event listener for `Tooltip`\n   * @this {Tooltip}\n   * @param {TouchEvent} e the `Event` object\n   */\n  handleTouch({ target }) {\n    const { tooltip, element } = this;\n\n    /* istanbul ignore next */\n    if (tooltip.contains(target) || target === element\n      || (target && element.contains(target))) ; else {\n      this.hide();\n    }\n  }\n\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const self = this;\n    const { tooltip, options } = self;\n    const callback = () => disposeTooltipComplete(self, () => super.dispose());\n\n    if (options.animation && isVisibleTip(tooltip, options.container)) {\n      self.options.delay = 0; // reset delay\n      self.hide(callback);\n    } else {\n      callback();\n    }\n  }\n}\n\nObjectAssign(Tooltip, {\n  selector: tooltipSelector,\n  init: tooltipInitCallback,\n  getInstance: getTooltipInstance,\n  styleTip,\n});\n\n/* Native JavaScript for Bootstrap 5 | Popover\n---------------------------------------------- */\n\n// POPOVER PRIVATE GC\n// ==================\nconst popoverSelector = `[${dataBsToggle}=\"${popoverString}\"],[data-tip=\"${popoverString}\"]`;\n\nconst popoverDefaults = {\n  ...tooltipDefaults,\n  /** @type {string} */\n  template: getTipTemplate(popoverString),\n  /** @type {string} */\n  btnClose: '<button class=\"btn-close\" aria-label=\"Close\"></button>',\n  /** @type {boolean} */\n  dismissible: false,\n  /** @type {string?} */\n  content: null,\n};\n\n// POPOVER DEFINITION\n// ==================\n/** Returns a new `Popover` instance. */\nclass Popover extends Tooltip {\n  /* eslint-disable -- we want to specify Popover Options */\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.Popover=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n  }\n  /**\n   * Returns component name string.\n   */ \n  get name() { return popoverComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return popoverDefaults; }\n  /* eslint-enable */\n\n  /* extend original `show()` */\n  show() {\n    super.show();\n    // btn only exists within dismissible popover\n    const { options, btn } = this;\n    /* istanbul ignore else */\n    if (options.dismissible && btn) setTimeout(() => focus(btn), 17);\n  }\n}\n\n/**\n * Static method which returns an existing `Popover` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Popover>}\n */\nconst getPopoverInstance = (element) => getInstance(element, popoverComponent);\n\n/**\n * A `Popover` initialization callback.\n * @type {BSN.InitCallback<Popover>}\n */\nconst popoverInitCallback = (element) => new Popover(element);\n\nObjectAssign(Popover, {\n  selector: popoverSelector,\n  init: popoverInitCallback,\n  getInstance: getPopoverInstance,\n  styleTip,\n});\n\n/**\n * Shortcut for `HTMLElement.getElementsByTagName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByTagName`.\n *\n * @param {string} selector the tag name\n * @param {ParentNode=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement>} the 'HTMLCollection'\n */\nfunction getElementsByTagName(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.getElementsByTagName(selector);\n}\n\n/** @type {string} */\nconst scrollspyString = 'scrollspy';\n\n/** @type {string} */\nconst scrollspyComponent = 'ScrollSpy';\n\n/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults = {\n  offset: 10,\n  target: null,\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<ScrollSpy>}\n */\nconst getScrollSpyInstance = (element) => getInstance(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n * @type {BSN.InitCallback<ScrollSpy>}\n */\nconst scrollspyInitCallback = (element) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = OriginalEvent(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n */\nfunction updateSpyTargets(self) {\n  const {\n    target, scrollTarget, options, itemsLength, scrollHeight, element,\n  } = self;\n  const { offset } = options;\n  const isWin = isWindow(scrollTarget);\n\n  const links = target && getElementsByTagName('A', target);\n  const scrollHEIGHT = scrollTarget && getScrollHeight(scrollTarget);\n\n  self.scrollTop = isWin ? scrollTarget.scrollY : scrollTarget.scrollTop;\n\n  // only update items/offsets once or with each mutation\n  /* istanbul ignore else */\n  if (links && (itemsLength !== links.length || scrollHEIGHT !== scrollHeight)) {\n    let href;\n    let targetItem;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    [...links].forEach((link) => {\n      href = getAttribute(link, 'href');\n      targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#'\n        && querySelector(href, getDocument(element));\n\n      if (targetItem) {\n        self.items.push(link);\n        rect = getBoundingClientRect(targetItem);\n        self.offsets.push((isWin ? rect.top + self.scrollTop : targetItem.offsetTop) - offset);\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n}\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n * @param {Node | Window} scrollTarget the `ScrollSpy` instance\n * @return {number} `scrollTarget` height\n */\nfunction getScrollHeight(scrollTarget) {\n  return isHTMLElement(scrollTarget)\n    ? scrollTarget.scrollHeight\n    : getDocumentElement(scrollTarget).scrollHeight;\n}\n\n/**\n * Returns the height property of the scrolling element.\n * @param {ScrollSpy} params the `ScrollSpy` instance\n * @returns {number}\n */\nfunction getOffsetHeight({ element, scrollTarget }) {\n  return (isWindow(scrollTarget))\n    ? scrollTarget.innerHeight\n    : getBoundingClientRect(element).height;\n}\n\n/**\n * Clear all items of the target.\n * @param {HTMLElement} target a single item\n */\nfunction clear(target) {\n  [...getElementsByTagName('A', target)].forEach((item) => {\n    if (hasClass(item, activeClass)) removeClass(item, activeClass);\n  });\n}\n\n/**\n * Activates a new item.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {HTMLElement} item a single item\n */\nfunction activate(self, item) {\n  const { target, element } = self;\n  clear(target);\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    parentItem = parentItem.parentElement;\n    if (hasClass(parentItem, 'nav') || hasClass(parentItem, 'dropdown-menu')) parents.push(parentItem);\n  }\n\n  parents.forEach((menuItem) => {\n    /** @type {HTMLElement?} */\n    const parentLink = menuItem.previousElementSibling;\n\n    /* istanbul ignore else */\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n}\n\n/**\n * Toggles on/off the component event listener.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {boolean=} add when `true`, listener is added\n */\nfunction toggleSpyHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.scrollTarget, scrollEvent, self.refresh, passiveHandler);\n}\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nclass ScrollSpy extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.ScrollSpy=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element & options\n    const { element, options } = self;\n\n    // additional properties\n    /** @type {HTMLElement?} */\n    self.target = querySelector(options.target, getDocument(element));\n\n    // invalidate\n    if (!self.target) return;\n\n    // set initial state\n    /** @type {HTMLElement | Window} */\n    self.scrollTarget = element.clientHeight < element.scrollHeight\n      ? element : getWindow(element);\n    /** @type {number} */\n    self.scrollTop = 0;\n    /** @type {number} */\n    self.maxScroll = 0;\n    /** @type {number} */\n    self.scrollHeight = 0;\n    /** @type {HTMLElement?} */\n    self.activeItem = null;\n    /** @type {HTMLElement[]} */\n    self.items = [];\n    /** @type {number} */\n    self.itemsLength = 0;\n    /** @type {number[]} */\n    self.offsets = [];\n\n    // bind events\n    self.refresh = self.refresh.bind(self);\n\n    // add event handlers\n    toggleSpyHandlers(self, true);\n\n    self.refresh();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return scrollspyComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return scrollspyDefaults; }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh() {\n    const self = this;\n    const { target } = self;\n\n    // check if target is visible and invalidate\n    /* istanbul ignore next */\n    if (target.offsetHeight === 0) return;\n\n    updateSpyTargets(self);\n\n    const {\n      scrollTop, maxScroll, itemsLength, items, activeItem,\n    } = self;\n\n    if (scrollTop >= maxScroll) {\n      const newActiveItem = items[itemsLength - 1];\n\n      /* istanbul ignore else */\n      if (activeItem !== newActiveItem) {\n        activate(self, newActiveItem);\n      }\n      return;\n    }\n\n    const { offsets } = self;\n\n    if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n      self.activeItem = null;\n      clear(target);\n      return;\n    }\n\n    items.forEach((item, i) => {\n      if (activeItem !== item && scrollTop >= offsets[i]\n        && (typeof offsets[i + 1] === 'undefined' || scrollTop < offsets[i + 1])) {\n        activate(self, item);\n      }\n    });\n  }\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    toggleSpyHandlers(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(ScrollSpy, {\n  selector: scrollspySelector,\n  init: scrollspyInitCallback,\n  getInstance: getScrollSpyInstance,\n});\n\n/**\n * A global namespace for aria-selected.\n * @type {string}\n */\nconst ariaSelected = 'aria-selected';\n\n/** @type {string} */\nconst tabString = 'tab';\n\n/** @type {string} */\nconst tabComponent = 'Tab';\n\n/* Native JavaScript for Bootstrap 5 | Tab\n------------------------------------------ */\n\n// TAB PRIVATE GC\n// ================\nconst tabSelector = `[${dataBsToggle}=\"${tabString}\"]`;\n\n/**\n * Static method which returns an existing `Tab` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tab>}\n */\nconst getTabInstance = (element) => getInstance(element, tabComponent);\n\n/**\n * A `Tab` initialization callback.\n * @type {BSN.InitCallback<Tab>}\n */\nconst tabInitCallback = (element) => new Tab(element);\n\n// TAB CUSTOM EVENTS\n// =================\nconst showTabEvent = OriginalEvent(`show.bs.${tabString}`);\nconst shownTabEvent = OriginalEvent(`shown.bs.${tabString}`);\nconst hideTabEvent = OriginalEvent(`hide.bs.${tabString}`);\nconst hiddenTabEvent = OriginalEvent(`hidden.bs.${tabString}`);\n\n/**\n * Stores the current active tab and its content\n * for a given `.nav` element.\n * @type {Map<HTMLElement, any>}\n */\nconst tabPrivate = new Map();\n\n// TAB PRIVATE METHODS\n// ===================\n/**\n * Executes after tab transition has finished.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabEnd(self) {\n  const { tabContent, nav } = self;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(tabContent, collapsingClass)) {\n    tabContent.style.height = '';\n    removeClass(tabContent, collapsingClass);\n  }\n\n  /* istanbul ignore else */\n  if (nav) Timer.clear(nav);\n}\n\n/**\n * Executes before showing the tab content.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabShow(self) {\n  const {\n    element, tabContent, content: nextContent, nav,\n  } = self;\n  const { tab } = nav && tabPrivate.get(nav);\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    const { currentHeight, nextHeight } = tabPrivate.get(element);\n    if (currentHeight === nextHeight) {\n      triggerTabEnd(self);\n    } else {\n      // enables height animation\n      setTimeout(() => {\n        tabContent.style.height = `${nextHeight}px`;\n        reflow(tabContent);\n        emulateTransitionEnd(tabContent, () => triggerTabEnd(self));\n      }, 50);\n    }\n  } else if (nav) Timer.clear(nav);\n\n  shownTabEvent.relatedTarget = tab;\n  dispatchEvent(element, shownTabEvent);\n}\n\n/**\n * Executes before hiding the tab.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabHide(self) {\n  const {\n    element, content: nextContent, tabContent, nav,\n  } = self;\n  const { tab, content } = nav && tabPrivate.get(nav);\n  let currentHeight = 0;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    [content, nextContent].forEach((c) => {\n      addClass(c, 'overflow-hidden');\n    });\n    currentHeight = content.scrollHeight || /* istanbul ignore next */0;\n  }\n\n  // update relatedTarget and dispatch event\n  showTabEvent.relatedTarget = tab;\n  hiddenTabEvent.relatedTarget = element;\n  dispatchEvent(element, showTabEvent);\n  if (showTabEvent.defaultPrevented) return;\n\n  addClass(nextContent, activeClass);\n  removeClass(content, activeClass);\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    const nextHeight = nextContent.scrollHeight;\n    tabPrivate.set(element, { currentHeight, nextHeight });\n\n    addClass(tabContent, collapsingClass);\n    tabContent.style.height = `${currentHeight}px`;\n    reflow(tabContent);\n    [content, nextContent].forEach((c) => {\n      removeClass(c, 'overflow-hidden');\n    });\n  }\n\n  if (nextContent && hasClass(nextContent, fadeClass)) {\n    setTimeout(() => {\n      addClass(nextContent, showClass);\n      emulateTransitionEnd(nextContent, () => {\n        triggerTabShow(self);\n      });\n    }, 1);\n  } else {\n    addClass(nextContent, showClass);\n    triggerTabShow(self);\n  }\n\n  dispatchEvent(tab, hiddenTabEvent);\n}\n\n/**\n * Returns the current active tab and its target content.\n * @param {Tab} self the `Tab` instance\n * @returns {Record<string, any>} the query result\n */\nfunction getActiveTab(self) {\n  const { nav } = self;\n\n  const activeTabs = getElementsByClassName(activeClass, nav);\n  /** @type {(HTMLElement)=} */\n  let tab;\n  /* istanbul ignore else */\n  if (activeTabs.length === 1\n    && !dropdownMenuClasses.some((c) => hasClass(activeTabs[0].parentElement, c))) {\n    [tab] = activeTabs;\n  } else if (activeTabs.length > 1) {\n    tab = activeTabs[activeTabs.length - 1];\n  }\n  const content = tab ? getTargetElement(tab) : null;\n  return { tab, content };\n}\n\n/**\n * Returns a parent dropdown.\n * @param {HTMLElement} element the `Tab` element\n * @returns {HTMLElement?} the parent dropdown\n */\nfunction getParentDropdown(element) {\n  const dropdown = closest(element, `.${dropdownMenuClasses.join(',.')}`);\n  return dropdown ? querySelector(`.${dropdownMenuClasses[0]}-toggle`, dropdown) : null;\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Tab} self the `Tab` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleTabHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, tabClickHandler);\n}\n\n// TAB EVENT HANDLER\n// =================\n/**\n * Handles the `click` event listener.\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction tabClickHandler(e) {\n  const self = getTabInstance(this);\n  /* istanbul ignore next: must filter */\n  if (!self) return;\n  e.preventDefault();\n\n  self.show();\n}\n\n// TAB DEFINITION\n// ==============\n/** Creates a new `Tab` instance. */\nclass Tab extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const content = getTargetElement(element);\n\n    // no point initializing a tab without a corresponding content\n    if (!content) return;\n\n    const nav = closest(element, '.nav');\n    const container = closest(content, '.tab-content');\n\n    /** @type {HTMLElement?} */\n    self.nav = nav;\n    /** @type {HTMLElement} */\n    self.content = content;\n    /** @type {HTMLElement?} */\n    self.tabContent = container;\n\n    // event targets\n    /** @type {HTMLElement?} */\n    self.dropdown = getParentDropdown(element);\n\n    // show first Tab instance of none is shown\n    // suggested on #432\n    const { tab } = getActiveTab(self);\n    if (nav && !tab) {\n      const firstTab = querySelector(tabSelector, nav);\n      const firstTabContent = firstTab && getTargetElement(firstTab);\n\n      /* istanbul ignore else */\n      if (firstTabContent) {\n        addClass(firstTab, activeClass);\n        addClass(firstTabContent, showClass);\n        addClass(firstTabContent, activeClass);\n        setAttribute(element, ariaSelected, 'true');\n      }\n    }\n\n    // add event listener\n    toggleTabHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */  \n  get name() { return tabComponent; }\n  /* eslint-enable */\n\n  // TAB PUBLIC METHODS\n  // ==================\n  /** Shows the tab to the user. */\n  show() {\n    const self = this;\n    const {\n      element, content: nextContent, nav, dropdown,\n    } = self;\n\n    /* istanbul ignore else */\n    if (!(nav && Timer.get(nav)) && !hasClass(element, activeClass)) {\n      const { tab, content } = getActiveTab(self);\n\n      /* istanbul ignore else */\n      if (nav) tabPrivate.set(nav, { tab, content });\n\n      // update relatedTarget and dispatch\n      hideTabEvent.relatedTarget = element;\n\n      dispatchEvent(tab, hideTabEvent);\n      if (hideTabEvent.defaultPrevented) return;\n\n      addClass(element, activeClass);\n      setAttribute(element, ariaSelected, 'true');\n\n      const activeDropdown = getParentDropdown(tab);\n      if (activeDropdown && hasClass(activeDropdown, activeClass)) {\n        removeClass(activeDropdown, activeClass);\n      }\n\n      /* istanbul ignore else */\n      if (nav) {\n        const toggleTab = () => {\n          removeClass(tab, activeClass);\n          setAttribute(tab, ariaSelected, 'false');\n          if (dropdown && !hasClass(dropdown, activeClass)) addClass(dropdown, activeClass);\n        };\n\n        if (hasClass(content, fadeClass) || hasClass(nextContent, fadeClass)) {\n          Timer.set(nav, toggleTab, 1);\n        } else toggleTab();\n      }\n\n      removeClass(content, showClass);\n      if (hasClass(content, fadeClass)) {\n        emulateTransitionEnd(content, () => triggerTabHide(self));\n      } else {\n        triggerTabHide(self);\n      }\n    }\n  }\n\n  /** Removes the `Tab` component from the target element. */\n  dispose() {\n    toggleTabHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Tab, {\n  selector: tabSelector,\n  init: tabInitCallback,\n  getInstance: getTabInstance,\n});\n\n/** @type {string} */\nconst toastString = 'toast';\n\n/** @type {string} */\nconst toastComponent = 'Toast';\n\n/* Native JavaScript for Bootstrap 5 | Toast\n-------------------------------------------- */\n\n// TOAST PRIVATE GC\n// ================\nconst toastSelector = `.${toastString}`;\nconst toastDismissSelector = `[${dataBsDismiss}=\"${toastString}\"]`;\nconst toastToggleSelector = `[${dataBsToggle}=\"${toastString}\"]`;\nconst showingClass = 'showing';\n/** @deprecated */\nconst hideClass = 'hide';\n\nconst toastDefaults = {\n  animation: true,\n  autohide: true,\n  delay: 5000,\n};\n\n/**\n * Static method which returns an existing `Toast` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Toast>}\n */\nconst getToastInstance = (element) => getInstance(element, toastComponent);\n\n/**\n * A `Toast` initialization callback.\n * @type {BSN.InitCallback<Toast>}\n */\nconst toastInitCallback = (element) => new Toast(element);\n\n// TOAST CUSTOM EVENTS\n// ===================\nconst showToastEvent = OriginalEvent(`show.bs.${toastString}`);\nconst shownToastEvent = OriginalEvent(`shown.bs.${toastString}`);\nconst hideToastEvent = OriginalEvent(`hide.bs.${toastString}`);\nconst hiddenToastEvent = OriginalEvent(`hidden.bs.${toastString}`);\n\n// TOAST PRIVATE METHODS\n// =====================\n/**\n * Executes after the toast is shown to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToastComplete(self) {\n  const { element, options } = self;\n  removeClass(element, showingClass);\n  Timer.clear(element, showingClass);\n\n  dispatchEvent(element, shownToastEvent);\n  /* istanbul ignore else */\n  if (options.autohide) {\n    Timer.set(element, () => self.hide(), options.delay, toastString);\n  }\n}\n\n/**\n * Executes after the toast is hidden to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToastComplete(self) {\n  const { element } = self;\n  removeClass(element, showingClass);\n  removeClass(element, showClass);\n  addClass(element, hideClass); // B/C\n  Timer.clear(element, toastString);\n  dispatchEvent(element, hiddenToastEvent);\n}\n\n/**\n * Executes before hiding the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToast(self) {\n  const { element, options } = self;\n  addClass(element, showingClass);\n\n  if (options.animation) {\n    reflow(element);\n    emulateTransitionEnd(element, () => hideToastComplete(self));\n  } else {\n    hideToastComplete(self);\n  }\n}\n\n/**\n * Executes before showing the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToast(self) {\n  const { element, options } = self;\n  Timer.set(element, () => {\n    removeClass(element, hideClass); // B/C\n    reflow(element);\n    addClass(element, showClass);\n    addClass(element, showingClass);\n\n    if (options.animation) {\n      emulateTransitionEnd(element, () => showToastComplete(self));\n    } else {\n      showToastComplete(self);\n    }\n  }, 17, showingClass);\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Toast} self the `Toast` instance\n * @param {boolean=} add when `true`, it will add the listener\n */\nfunction toggleToastHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const {\n    element, triggers, dismiss, options,\n  } = self;\n\n  /* istanbul ignore else */\n  if (dismiss) {\n    action(dismiss, mouseclickEvent, self.hide);\n  }\n\n  /* istanbul ignore else */\n  if (options.autohide) {\n    [focusinEvent, focusoutEvent, mouseenterEvent, mouseleaveEvent]\n      .forEach((e) => action(element, e, interactiveToastHandler));\n  }\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, toastClickHandler));\n  }\n}\n\n// TOAST EVENT HANDLERS\n// ====================\n/**\n * Executes after the instance has been disposed.\n * @param {Toast} self the `Toast` instance\n */\nfunction completeDisposeToast(self) {\n  Timer.clear(self.element, toastString);\n  toggleToastHandlers(self);\n}\n\n/**\n * Handles the `click` event listener for toast.\n * @param {MouseEvent} e the `Event` object\n */\nfunction toastClickHandler(e) {\n  const { target } = e;\n\n  const trigger = target && closest(target, toastToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getToastInstance(element);\n\n  /* istanbul ignore else */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n  self.relatedTarget = trigger;\n  self.show();\n}\n\n/**\n * Executes when user interacts with the toast without closing it,\n * usually by hovering or focusing it.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Toast` instance\n */\nfunction interactiveToastHandler(e) {\n  const element = this;\n  const self = getToastInstance(element);\n  const { type, relatedTarget } = e;\n\n  /* istanbul ignore next: a solid filter is required */\n  if (!self || (element === relatedTarget || element.contains(relatedTarget))) return;\n\n  if ([mouseenterEvent, focusinEvent].includes(type)) {\n    Timer.clear(element, toastString);\n  } else {\n    Timer.set(element, () => self.hide(), self.options.delay, toastString);\n  }\n}\n\n// TOAST DEFINITION\n// ================\n/** Creates a new `Toast` instance. */\nclass Toast extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target `.toast` element\n   * @param {BSN.Options.Toast=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n    const { element, options } = self;\n\n    // set fadeClass, the options.animation will override the markup\n    if (options.animation && !hasClass(element, fadeClass)) addClass(element, fadeClass);\n    else if (!options.animation && hasClass(element, fadeClass)) removeClass(element, fadeClass);\n\n    // dismiss button\n    /** @type {HTMLElement?} */\n    self.dismiss = querySelector(toastDismissSelector, element);\n\n    // toast can have multiple triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(toastToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // bind\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n\n    // add event listener\n    toggleToastHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */  \n  get name() { return toastComponent; }\n  /**\n   * Returns component default options.\n   */  \n  get defaults() { return toastDefaults; }\n  /* eslint-enable */\n\n  /**\n   * Returns *true* when toast is visible.\n   */\n  get isShown() { return hasClass(this.element, showClass); }\n\n  // TOAST PUBLIC METHODS\n  // ====================\n  /** Shows the toast. */\n  show() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (element && !isShown) {\n      dispatchEvent(element, showToastEvent);\n      if (showToastEvent.defaultPrevented) return;\n\n      showToast(self);\n    }\n  }\n\n  /** Hides the toast. */\n  hide() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (element && isShown) {\n      dispatchEvent(element, hideToastEvent);\n      if (hideToastEvent.defaultPrevented) return;\n      hideToast(self);\n    }\n  }\n\n  /** Removes the `Toast` component from the target element. */\n  dispose() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (isShown) {\n      removeClass(element, showClass);\n    }\n\n    completeDisposeToast(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Toast, {\n  selector: toastSelector,\n  init: toastInitCallback,\n  getInstance: getToastInstance,\n});\n\n/**\n * Check if element matches a CSS selector.\n *\n * @param {HTMLElement} target\n * @param {string} selector\n * @returns {boolean}\n */\nfunction matches(target, selector) {\n  return target.matches(selector);\n}\n\n/** @type {Record<string, any>} */\nconst componentsList = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n};\n\n/**\n * Initialize all matched `Element`s for one component.\n * @param {BSN.InitCallback<any>} callback\n * @param {NodeList | Node[]} collection\n */\nfunction initComponentDataAPI(callback, collection) {\n  [...collection].forEach((x) => callback(x));\n}\n\n/**\n * Remove one component from a target container element or all in the page.\n * @param {string} component the component name\n * @param {ParentNode} context parent `Node`\n */\nfunction removeComponentDataAPI(component, context) {\n  const compData = Data.getAllFor(component);\n\n  if (compData) {\n    [...compData].forEach((x) => {\n      const [element, instance] = x;\n      if (context.contains(element)) instance.dispose();\n    });\n  }\n}\n\n/**\n * Initialize all BSN components for a target container.\n * @param {ParentNode=} context parent `Node`\n */\nfunction initCallback(context) {\n  const lookUp = context && context.nodeName ? context : document;\n  const elemCollection = [...getElementsByTagName('*', lookUp)];\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    const { init, selector } = componentsList[comp];\n    initComponentDataAPI(init, elemCollection.filter((item) => matches(item, selector)));\n  });\n}\n\n/**\n * Remove all BSN components for a target container.\n * @param {ParentNode=} context parent `Node`\n */\nfunction removeDataAPI(context) {\n  const lookUp = context && context.nodeName ? context : document;\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    removeComponentDataAPI(comp, lookUp);\n  });\n}\n\n// bulk initialize all components\nif (document.body) initCallback();\nelse {\n  addListener(document, 'DOMContentLoaded', () => initCallback(), { once: true });\n}\n\nconst BSN = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n\n  initCallback,\n  removeDataAPI,\n  Version,\n  EventListener: Listener,\n};\n\nexport { BSN as default };\n","import \"../css/common2.css\";\nimport BSN from \"bootstrap.native\";\n// import { setTimeout } from \"core-js\";\n// const myModal = new BSN.Modal(\"#subscription-modal\");\n// //импортируем бутстрап (делаем эскиз) и передаем ссылку на модалку\n// //====================================\n// //https://thednp.github.io/bootstrap.native/\n\n// //show.bs.modal\n// //This event fires immediately when the show instance method is called.\n// //This event can be default prevented.\n// //====================================\n// //hide.bs.modal\n// //This event is fired immediately when the hide instance method has been called.\n// //This event can be default prevented.\n// //====================================\n// const PROMPT_DELAYS = 3000;\n// // //задержка\n// let promptCounter = 0;\n// // // счетчик нотификашек\n// const MAX_PROMPT_ETEMP = 3;\n// // // количество попыток\n\n// let hasSubscribed = false;\n// // // подписалися?\n// // const intervalId = setInterval(() => {\n// //   if (promptCounter === MAX_PROMPT_ETEMP || hasSubscribed) {\n// //     // если счетчик нотификашек = 3 или есть подписка\n// //     clearInterval(intervalId);\n// //     // очищаем интервальный вызов функций\n// //     console.log(`Конец нотификации`);\n// //     return;\n// //     // обрываем вызов функций\n// //   }\n// //   console.log(`Подпишитесь на нашу рассылку`, Date.now());\n// //   promptCounter += 1;\n// //   // на каждом выполнении в счетчик нотификашек делаем +1\n// // }, PROMPT_DELAYS);\n// //====================================\n// //====================================\n// //====================================\n\nconst refs = {\n  modal: document.querySelector(\"#subscription-modal\"),\n  btnClose: document.querySelector('[data-dismiss=\"modal\"]'),\n  subscribeBtn: document.querySelector(\"button[data-subscribe]\"),\n};\nconst PROMPT_DELAY = 3000;\n// // //задержка\nconst MAX_PROMPT_ATTEMPTS = 3;\n// // // количество попыток\nlet promptCounter = 0;\n// // // счетчик нотификашек\nlet hasSubscribed = false;\n// // // подписалися?\nconst modal = new BSN.Modal(\"#subscription-modal\");\n\nopenModal();\n\nrefs.modal.addEventListener(\"hide.bs.modal\", openModal);\n// // слушатель событий модалка и действие закрытие модалки (вн ивент бутстрап найтив) + сет таймаут с запускам модадки\n\nrefs.subscribeBtn.addEventListener(\"click\", onSubscribeBtnClick);\n// при клике на кнопку подписаться запуск функции отмена надоедалки\nrefs.btnClose.addEventListener(\"click\", () => modal.hide());\n// //при клике на кнопку закрыть закрываем модаку\nfunction openModal() {\n  if (promptCounter === MAX_PROMPT_ATTEMPTS || hasSubscribed) {\n    console.log(\"Максимальное кол-во надоеданий или подписался\");\n    return;\n  }\n\n  setTimeout(() => {\n    console.log(\"Открываем надоедалку\");\n    modal.show();\n    promptCounter += 1;\n  }, PROMPT_DELAY);\n}\n// //проверка счетчика + сет таймаут с запускам модадки\nfunction onSubscribeBtnClick() {\n  hasSubscribed = true;\n  // запись тру в hasSubscribed\n  modal.hide();\n  // закріваем модалку\n}\n"]}